  <div id="fileHeader">
    <h1>base.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>rails-2.3.2/activeresource/lib/active_resource/base.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Mar 15 23:31:38 -0500 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'active_resource/connection'
require 'cgi'
require 'set'

module ActiveResource
  # ActiveResource::Base is the main class for mapping RESTful resources as models in a Rails application.
  #
  # For an outline of what Active Resource is capable of, see link:files/vendor/rails/activeresource/README.html.
  #
  # == Automated mapping
  #
  # Active Resource objects represent your RESTful resources as manipulatable Ruby objects.  To map resources
  # to Ruby objects, Active Resource only needs a class name that corresponds to the resource name (e.g., the class
  # Person maps to the resources people, very similarly to Active Record) and a +site+ value, which holds the
  # URI of the resources.
  #
  #   class Person &lt; ActiveResource::Base
  #     self.site = &quot;http://api.people.com:3000/&quot;
  #   end
  #
  # Now the Person class is mapped to RESTful resources located at &lt;tt&gt;http://api.people.com:3000/people/&lt;/tt&gt;, and
  # you can now use Active Resource's lifecycles methods to manipulate resources. In the case where you already have
  # an existing model with the same name as the desired RESTful resource you can set the +element_name+ value.
  #
  #   class PersonResource &lt; ActiveResource::Base
  #     self.site = &quot;http://api.people.com:3000/&quot;
  #     self.element_name = &quot;person&quot;
  #   end
  #
  #
  # == Lifecycle methods
  #
  # Active Resource exposes methods for creating, finding, updating, and deleting resources
  # from REST web services.
  #
  #   ryan = Person.new(:first =&gt; 'Ryan', :last =&gt; 'Daigle')
  #   ryan.save                # =&gt; true
  #   ryan.id                  # =&gt; 2
  #   Person.exists?(ryan.id)  # =&gt; true
  #   ryan.exists?             # =&gt; true
  #
  #   ryan = Person.find(1)
  #   # Resource holding our newly created Person object
  #
  #   ryan.first = 'Rizzle'
  #   ryan.save                # =&gt; true
  #
  #   ryan.destroy             # =&gt; true
  #
  # As you can see, these are very similar to Active Record's lifecycle methods for database records.
  # You can read more about each of these methods in their respective documentation.
  #
  # === Custom REST methods
  #
  # Since simple CRUD/lifecycle methods can't accomplish every task, Active Resource also supports
  # defining your own custom REST methods. To invoke them, Active Resource provides the &lt;tt&gt;get&lt;/tt&gt;,
  # &lt;tt&gt;post&lt;/tt&gt;, &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;\delete&lt;/tt&gt; methods where you can specify a custom REST method
  # name to invoke.
  #
  #   # POST to the custom 'register' REST method, i.e. POST /people/new/register.xml.
  #   Person.new(:name =&gt; 'Ryan').post(:register)
  #   # =&gt; { :id =&gt; 1, :name =&gt; 'Ryan', :position =&gt; 'Clerk' }
  #
  #   # PUT an update by invoking the 'promote' REST method, i.e. PUT /people/1/promote.xml?position=Manager.
  #   Person.find(1).put(:promote, :position =&gt; 'Manager')
  #   # =&gt; { :id =&gt; 1, :name =&gt; 'Ryan', :position =&gt; 'Manager' }
  #
  #   # GET all the positions available, i.e. GET /people/positions.xml.
  #   Person.get(:positions)
  #   # =&gt; [{:name =&gt; 'Manager'}, {:name =&gt; 'Clerk'}]
  #
  #   # DELETE to 'fire' a person, i.e. DELETE /people/1/fire.xml.
  #   Person.find(1).delete(:fire)
  #
  # For more information on using custom REST methods, see the
  # ActiveResource::CustomMethods documentation.
  #
  # == Validations
  #
  # You can validate resources client side by overriding validation methods in the base class.
  #
  #   class Person &lt; ActiveResource::Base
  #      self.site = &quot;http://api.people.com:3000/&quot;
  #      protected
  #        def validate
  #          errors.add(&quot;last&quot;, &quot;has invalid characters&quot;) unless last =~ /[a-zA-Z]*/
  #        end
  #   end
  #
  # See the ActiveResource::Validations documentation for more information.
  #
  # == Authentication
  #
  # Many REST APIs will require authentication, usually in the form of basic
  # HTTP authentication.  Authentication can be specified by:
  # * putting the credentials in the URL for the +site+ variable.
  #
  #    class Person &lt; ActiveResource::Base
  #      self.site = &quot;http://ryan:password@api.people.com:3000/&quot;
  #    end
  #
  # * defining +user+ and/or +password+ variables
  #
  #    class Person &lt; ActiveResource::Base
  #      self.site = &quot;http://api.people.com:3000/&quot;
  #      self.user = &quot;ryan&quot;
  #      self.password = &quot;password&quot;
  #    end
  #
  # For obvious security reasons, it is probably best if such services are available
  # over HTTPS.
  #
  # Note: Some values cannot be provided in the URL passed to site.  e.g. email addresses
  # as usernames.  In those situations you should use the separate user and password option.
  # == Errors &amp; Validation
  #
  # Error handling and validation is handled in much the same manner as you're used to seeing in
  # Active Record.  Both the response code in the HTTP response and the body of the response are used to
  # indicate that an error occurred.
  #
  # === Resource errors
  #
  # When a GET is requested for a resource that does not exist, the HTTP &lt;tt&gt;404&lt;/tt&gt; (Resource Not Found)
  # response code will be returned from the server which will raise an ActiveResource::ResourceNotFound
  # exception.
  #
  #   # GET http://api.people.com:3000/people/999.xml
  #   ryan = Person.find(999) # 404, raises ActiveResource::ResourceNotFound
  #
  # &lt;tt&gt;404&lt;/tt&gt; is just one of the HTTP error response codes that Active Resource will handle with its own exception. The
  # following HTTP response codes will also result in these exceptions:
  # 
  # * 200..399 - Valid response, no exception (other than 301, 302)
  # * 301, 302 - ActiveResource::Redirection
  # * 400 - ActiveResource::BadRequest
  # * 401 - ActiveResource::UnauthorizedAccess
  # * 403 - ActiveResource::ForbiddenAccess
  # * 404 - ActiveResource::ResourceNotFound
  # * 405 - ActiveResource::MethodNotAllowed
  # * 409 - ActiveResource::ResourceConflict
  # * 422 - ActiveResource::ResourceInvalid (rescued by save as validation errors)
  # * 401..499 - ActiveResource::ClientError
  # * 500..599 - ActiveResource::ServerError
  # * Other - ActiveResource::ConnectionError
  #
  # These custom exceptions allow you to deal with resource errors more naturally and with more precision
  # rather than returning a general HTTP error.  For example:
  #
  #   begin
  #     ryan = Person.find(my_id)
  #   rescue ActiveResource::ResourceNotFound
  #     redirect_to :action =&gt; 'not_found'
  #   rescue ActiveResource::ResourceConflict, ActiveResource::ResourceInvalid
  #     redirect_to :action =&gt; 'new'
  #   end
  #
  # === Validation errors
  #
  # Active Resource supports validations on resources and will return errors if any these validations fail
  # (e.g., &quot;First name can not be blank&quot; and so on).  These types of errors are denoted in the response by
  # a response code of &lt;tt&gt;422&lt;/tt&gt; and an XML representation of the validation errors.  The save operation will
  # then fail (with a &lt;tt&gt;false&lt;/tt&gt; return value) and the validation errors can be accessed on the resource in question.
  #
  #   ryan = Person.find(1)
  #   ryan.first # =&gt; ''
  #   ryan.save  # =&gt; false
  #
  #   # When
  #   # PUT http://api.people.com:3000/people/1.xml
  #   # is requested with invalid values, the response is:
  #   #
  #   # Response (422):
  #   # &lt;errors type=&quot;array&quot;&gt;&lt;error&gt;First cannot be empty&lt;/error&gt;&lt;/errors&gt;
  #   #
  #
  #   ryan.errors.invalid?(:first)  # =&gt; true
  #   ryan.errors.full_messages     # =&gt; ['First cannot be empty']
  #
  # Learn more about Active Resource's validation features in the ActiveResource::Validations documentation.
  #
  # === Timeouts
  #
  # Active Resource relies on HTTP to access RESTful APIs and as such is inherently susceptible to slow or
  # unresponsive servers. In such cases, your Active Resource method calls could \timeout. You can control the
  # amount of time before Active Resource times out with the +timeout+ variable.
  #
  #   class Person &lt; ActiveResource::Base
  #     self.site = &quot;http://api.people.com:3000/&quot;
  #     self.timeout = 5
  #   end
  #
  # This sets the +timeout+ to 5 seconds. You can adjust the +timeout+ to a value suitable for the RESTful API
  # you are accessing. It is recommended to set this to a reasonably low value to allow your Active Resource
  # clients (especially if you are using Active Resource in a Rails application) to fail-fast (see
  # http://en.wikipedia.org/wiki/Fail-fast) rather than cause cascading failures that could incapacitate your
  # server.
  #
  # When a \timeout occurs, an ActiveResource::TimeoutError is raised. You should rescue from
  # ActiveResource::TimeoutError in your Active Resource method calls.
  #
  # Internally, Active Resource relies on Ruby's Net::HTTP library to make HTTP requests. Setting +timeout+
  # sets the &lt;tt&gt;read_timeout&lt;/tt&gt; of the internal Net::HTTP instance to the same value. The default
  # &lt;tt&gt;read_timeout&lt;/tt&gt; is 60 seconds on most Ruby implementations.
  class Base
    ##
    # :singleton-method:
    # The logger for diagnosing and tracing Active Resource calls.
    cattr_accessor :logger

    class &lt;&lt; self
      # Gets the URI of the REST resources to map for this class.  The site variable is required for
      # Active Resource's mapping to work.
      def site
        # Not using superclass_delegating_reader because don't want subclasses to modify superclass instance
        #
        # With superclass_delegating_reader
        #
        #   Parent.site = 'http://anonymous@test.com'
        #   Subclass.site # =&gt; 'http://anonymous@test.com'
        #   Subclass.site.user = 'david'
        #   Parent.site # =&gt; 'http://david@test.com'
        #
        # Without superclass_delegating_reader (expected behaviour)
        #
        #   Parent.site = 'http://anonymous@test.com'
        #   Subclass.site # =&gt; 'http://anonymous@test.com'
        #   Subclass.site.user = 'david' # =&gt; TypeError: can't modify frozen object
        #
        if defined?(@site)
          @site
        elsif superclass != Object &amp;&amp; superclass.site
          superclass.site.dup.freeze
        end
      end

      # Sets the URI of the REST resources to map for this class to the value in the +site+ argument.
      # The site variable is required for Active Resource's mapping to work.
      def site=(site)
        @connection = nil
        if site.nil?
          @site = nil
        else
          @site = create_site_uri_from(site)
          @user = URI.decode(@site.user) if @site.user
          @password = URI.decode(@site.password) if @site.password
        end
      end

      # Gets the \user for REST HTTP authentication.
      def user
        # Not using superclass_delegating_reader. See +site+ for explanation
        if defined?(@user)
          @user
        elsif superclass != Object &amp;&amp; superclass.user
          superclass.user.dup.freeze
        end
      end

      # Sets the \user for REST HTTP authentication.
      def user=(user)
        @connection = nil
        @user = user
      end

      # Gets the \password for REST HTTP authentication.
      def password
        # Not using superclass_delegating_reader. See +site+ for explanation
        if defined?(@password)
          @password
        elsif superclass != Object &amp;&amp; superclass.password
          superclass.password.dup.freeze
        end
      end

      # Sets the \password for REST HTTP authentication.
      def password=(password)
        @connection = nil
        @password = password
      end

      # Sets the format that attributes are sent and received in from a mime type reference:
      #
      #   Person.format = :json
      #   Person.find(1) # =&gt; GET /people/1.json
      #
      #   Person.format = ActiveResource::Formats::XmlFormat
      #   Person.find(1) # =&gt; GET /people/1.xml
      #
      # Default format is &lt;tt&gt;:xml&lt;/tt&gt;.
      def format=(mime_type_reference_or_format)
        format = mime_type_reference_or_format.is_a?(Symbol) ?
          ActiveResource::Formats[mime_type_reference_or_format] : mime_type_reference_or_format

        write_inheritable_attribute(:format, format)
        connection.format = format if site
      end

      # Returns the current format, default is ActiveResource::Formats::XmlFormat.
      def format
        read_inheritable_attribute(:format) || ActiveResource::Formats[:xml]
      end

      # Sets the number of seconds after which requests to the REST API should time out.
      def timeout=(timeout)
        @connection = nil
        @timeout = timeout
      end

      # Gets the number of seconds after which requests to the REST API should time out.
      def timeout
        if defined?(@timeout)
          @timeout
        elsif superclass != Object &amp;&amp; superclass.timeout
          superclass.timeout
        end
      end

      # An instance of ActiveResource::Connection that is the base \connection to the remote service.
      # The +refresh+ parameter toggles whether or not the \connection is refreshed at every request
      # or not (defaults to &lt;tt&gt;false&lt;/tt&gt;).
      def connection(refresh = false)
        if defined?(@connection) || superclass == Object
          @connection = Connection.new(site, format) if refresh || @connection.nil?
          @connection.user = user if user
          @connection.password = password if password
          @connection.timeout = timeout if timeout
          @connection
        else
          superclass.connection
        end
      end

      def headers
        @headers ||= {}
      end

      # Do not include any modules in the default element name. This makes it easier to seclude ARes objects
      # in a separate namespace without having to set element_name repeatedly.
      attr_accessor_with_default(:element_name)    { to_s.split(&quot;::&quot;).last.underscore } #:nodoc:

      attr_accessor_with_default(:collection_name) { element_name.pluralize } #:nodoc:
      attr_accessor_with_default(:primary_key, 'id') #:nodoc:
      
      # Gets the \prefix for a resource's nested URL (e.g., &lt;tt&gt;prefix/collectionname/1.xml&lt;/tt&gt;)
      # This method is regenerated at runtime based on what the \prefix is set to.
      def prefix(options={})
        default = site.path
        default &lt;&lt; '/' unless default[-1..-1] == '/'
        # generate the actual method based on the current site path
        self.prefix = default
        prefix(options)
      end

      # An attribute reader for the source string for the resource path \prefix.  This
      # method is regenerated at runtime based on what the \prefix is set to.
      def prefix_source
        prefix # generate #prefix and #prefix_source methods first
        prefix_source
      end

      # Sets the \prefix for a resource's nested URL (e.g., &lt;tt&gt;prefix/collectionname/1.xml&lt;/tt&gt;).
      # Default value is &lt;tt&gt;site.path&lt;/tt&gt;.
      def prefix=(value = '/')
        # Replace :placeholders with '#{embedded options[:lookups]}'
        prefix_call = value.gsub(/:\w+/) { |key| &quot;\#{options[#{key}]}&quot; }

        # Clear prefix parameters in case they have been cached
        @prefix_parameters = nil

        # Redefine the new methods.
        code = &lt;&lt;-end_code
          def prefix_source() &quot;#{value}&quot; end
          def prefix(options={}) &quot;#{prefix_call}&quot; end
        end_code
        silence_warnings { instance_eval code, __FILE__, __LINE__ }
      rescue
        logger.error &quot;Couldn't set prefix: #{$!}\n  #{code}&quot;
        raise
      end

      alias_method :set_prefix, :prefix=  #:nodoc:

      alias_method :set_element_name, :element_name=  #:nodoc:
      alias_method :set_collection_name, :collection_name=  #:nodoc:

      # Gets the element path for the given ID in +id+.  If the +query_options+ parameter is omitted, Rails
      # will split from the \prefix options.
      #
      # ==== Options
      # +prefix_options+ - A \hash to add a \prefix to the request for nested URLs (e.g., &lt;tt&gt;:account_id =&gt; 19&lt;/tt&gt;
      #                    would yield a URL like &lt;tt&gt;/accounts/19/purchases.xml&lt;/tt&gt;).
      # +query_options+ - A \hash to add items to the query string for the request.
      #
      # ==== Examples
      #   Post.element_path(1)
      #   # =&gt; /posts/1.xml
      #
      #   Comment.element_path(1, :post_id =&gt; 5)
      #   # =&gt; /posts/5/comments/1.xml
      #
      #   Comment.element_path(1, :post_id =&gt; 5, :active =&gt; 1)
      #   # =&gt; /posts/5/comments/1.xml?active=1
      #
      #   Comment.element_path(1, {:post_id =&gt; 5}, {:active =&gt; 1})
      #   # =&gt; /posts/5/comments/1.xml?active=1
      #
      def element_path(id, prefix_options = {}, query_options = nil)
        prefix_options, query_options = split_options(prefix_options) if query_options.nil?
        &quot;#{prefix(prefix_options)}#{collection_name}/#{id}.#{format.extension}#{query_string(query_options)}&quot;
      end

      # Gets the collection path for the REST resources.  If the +query_options+ parameter is omitted, Rails
      # will split from the +prefix_options+.
      #
      # ==== Options
      # * +prefix_options+ - A hash to add a prefix to the request for nested URL's (e.g., &lt;tt&gt;:account_id =&gt; 19&lt;/tt&gt;
      #   would yield a URL like &lt;tt&gt;/accounts/19/purchases.xml&lt;/tt&gt;).
      # * +query_options+ - A hash to add items to the query string for the request.
      #
      # ==== Examples
      #   Post.collection_path
      #   # =&gt; /posts.xml
      #
      #   Comment.collection_path(:post_id =&gt; 5)
      #   # =&gt; /posts/5/comments.xml
      #
      #   Comment.collection_path(:post_id =&gt; 5, :active =&gt; 1)
      #   # =&gt; /posts/5/comments.xml?active=1
      #
      #   Comment.collection_path({:post_id =&gt; 5}, {:active =&gt; 1})
      #   # =&gt; /posts/5/comments.xml?active=1
      #
      def collection_path(prefix_options = {}, query_options = nil)
        prefix_options, query_options = split_options(prefix_options) if query_options.nil?
        &quot;#{prefix(prefix_options)}#{collection_name}.#{format.extension}#{query_string(query_options)}&quot;
      end

      alias_method :set_primary_key, :primary_key=  #:nodoc:

      # Creates a new resource instance and makes a request to the remote service
      # that it be saved, making it equivalent to the following simultaneous calls:
      #
      #   ryan = Person.new(:first =&gt; 'ryan')
      #   ryan.save
      #
      # Returns the newly created resource.  If a failure has occurred an
      # exception will be raised (see &lt;tt&gt;save&lt;/tt&gt;).  If the resource is invalid and
      # has not been saved then &lt;tt&gt;valid?&lt;/tt&gt; will return &lt;tt&gt;false&lt;/tt&gt;,
      # while &lt;tt&gt;new?&lt;/tt&gt; will still return &lt;tt&gt;true&lt;/tt&gt;.
      #
      # ==== Examples
      #   Person.create(:name =&gt; 'Jeremy', :email =&gt; 'myname@nospam.com', :enabled =&gt; true)
      #   my_person = Person.find(:first)
      #   my_person.email # =&gt; myname@nospam.com
      #
      #   dhh = Person.create(:name =&gt; 'David', :email =&gt; 'dhh@nospam.com', :enabled =&gt; true)
      #   dhh.valid? # =&gt; true
      #   dhh.new?   # =&gt; false
      #
      #   # We'll assume that there's a validation that requires the name attribute
      #   that_guy = Person.create(:name =&gt; '', :email =&gt; 'thatguy@nospam.com', :enabled =&gt; true)
      #   that_guy.valid? # =&gt; false
      #   that_guy.new?   # =&gt; true
      def create(attributes = {})
        self.new(attributes).tap { |resource| resource.save }
      end

      # Core method for finding resources.  Used similarly to Active Record's +find+ method.
      #
      # ==== Arguments
      # The first argument is considered to be the scope of the query.  That is, how many
      # resources are returned from the request.  It can be one of the following.
      #
      # * &lt;tt&gt;:one&lt;/tt&gt; - Returns a single resource.
      # * &lt;tt&gt;:first&lt;/tt&gt; - Returns the first resource found.
      # * &lt;tt&gt;:last&lt;/tt&gt; - Returns the last resource found.
      # * &lt;tt&gt;:all&lt;/tt&gt; - Returns every resource that matches the request.
      #
      # ==== Options
      #
      # * &lt;tt&gt;:from&lt;/tt&gt; - Sets the path or custom method that resources will be fetched from.
      # * &lt;tt&gt;:params&lt;/tt&gt; - Sets query and \prefix (nested URL) parameters.
      #
      # ==== Examples
      #   Person.find(1)
      #   # =&gt; GET /people/1.xml
      #
      #   Person.find(:all)
      #   # =&gt; GET /people.xml
      #
      #   Person.find(:all, :params =&gt; { :title =&gt; &quot;CEO&quot; })
      #   # =&gt; GET /people.xml?title=CEO
      #
      #   Person.find(:first, :from =&gt; :managers)
      #   # =&gt; GET /people/managers.xml
      #
      #   Person.find(:last, :from =&gt; :managers)
      #   # =&gt; GET /people/managers.xml
      #
      #   Person.find(:all, :from =&gt; &quot;/companies/1/people.xml&quot;)
      #   # =&gt; GET /companies/1/people.xml
      #
      #   Person.find(:one, :from =&gt; :leader)
      #   # =&gt; GET /people/leader.xml
      #
      #   Person.find(:all, :from =&gt; :developers, :params =&gt; { :language =&gt; 'ruby' })
      #   # =&gt; GET /people/developers.xml?language=ruby
      #
      #   Person.find(:one, :from =&gt; &quot;/companies/1/manager.xml&quot;)
      #   # =&gt; GET /companies/1/manager.xml
      #
      #   StreetAddress.find(1, :params =&gt; { :person_id =&gt; 1 })
      #   # =&gt; GET /people/1/street_addresses/1.xml
      def find(*arguments)
        scope   = arguments.slice!(0)
        options = arguments.slice!(0) || {}

        case scope
          when :all   then find_every(options)
          when :first then find_every(options).first
          when :last  then find_every(options).last
          when :one   then find_one(options)
          else             find_single(scope, options)
        end
      end

      # Deletes the resources with the ID in the +id+ parameter.
      #
      # ==== Options
      # All options specify \prefix and query parameters.
      #
      # ==== Examples
      #   Event.delete(2) # sends DELETE /events/2
      #
      #   Event.create(:name =&gt; 'Free Concert', :location =&gt; 'Community Center')
      #   my_event = Event.find(:first) # let's assume this is event with ID 7
      #   Event.delete(my_event.id) # sends DELETE /events/7
      #
      #   # Let's assume a request to events/5/cancel.xml
      #   Event.delete(params[:id]) # sends DELETE /events/5
      def delete(id, options = {})
        connection.delete(element_path(id, options))
      end

      # Asserts the existence of a resource, returning &lt;tt&gt;true&lt;/tt&gt; if the resource is found.
      #
      # ==== Examples
      #   Note.create(:title =&gt; 'Hello, world.', :body =&gt; 'Nothing more for now...')
      #   Note.exists?(1) # =&gt; true
      #
      #   Note.exists(1349) # =&gt; false
      def exists?(id, options = {})
        if id
          prefix_options, query_options = split_options(options[:params])
          path = element_path(id, prefix_options, query_options)
          response = connection.head(path, headers)
          response.code.to_i == 200
        end
        # id &amp;&amp; !find_single(id, options).nil?
      rescue ActiveResource::ResourceNotFound
        false
      end

      private
        # Find every resource
        def find_every(options)
          case from = options[:from]
          when Symbol
            instantiate_collection(get(from, options[:params]))
          when String
            path = &quot;#{from}#{query_string(options[:params])}&quot;
            instantiate_collection(connection.get(path, headers) || [])
          else
            prefix_options, query_options = split_options(options[:params])
            path = collection_path(prefix_options, query_options)
            instantiate_collection( (connection.get(path, headers) || []), prefix_options )
          end
        end

        # Find a single resource from a one-off URL
        def find_one(options)
          case from = options[:from]
          when Symbol
            instantiate_record(get(from, options[:params]))
          when String
            path = &quot;#{from}#{query_string(options[:params])}&quot;
            instantiate_record(connection.get(path, headers))
          end
        end

        # Find a single resource from the default URL
        def find_single(scope, options)
          prefix_options, query_options = split_options(options[:params])
          path = element_path(scope, prefix_options, query_options)
          instantiate_record(connection.get(path, headers), prefix_options)
        end

        def instantiate_collection(collection, prefix_options = {})
          collection.collect! { |record| instantiate_record(record, prefix_options) }
        end

        def instantiate_record(record, prefix_options = {})
          new(record).tap do |resource|
            resource.prefix_options = prefix_options
          end
        end


        # Accepts a URI and creates the site URI from that.
        def create_site_uri_from(site)
          site.is_a?(URI) ? site.dup : URI.parse(site)
        end

        # contains a set of the current prefix parameters.
        def prefix_parameters
          @prefix_parameters ||= prefix_source.scan(/:\w+/).map { |key| key[1..-1].to_sym }.to_set
        end

        # Builds the query string for the request.
        def query_string(options)
          &quot;?#{options.to_query}&quot; unless options.nil? || options.empty?
        end

        # split an option hash into two hashes, one containing the prefix options,
        # and the other containing the leftovers.
        def split_options(options = {})
          prefix_options, query_options = {}, {}

          (options || {}).each do |key, value|
            next if key.blank?
            (prefix_parameters.include?(key.to_sym) ? prefix_options : query_options)[key.to_sym] = value
          end

          [ prefix_options, query_options ]
        end
    end

    attr_accessor :attributes #:nodoc:
    attr_accessor :prefix_options #:nodoc:

    # Constructor method for \new resources; the optional +attributes+ parameter takes a \hash
    # of attributes for the \new resource.
    #
    # ==== Examples
    #   my_course = Course.new
    #   my_course.name = &quot;Western Civilization&quot;
    #   my_course.lecturer = &quot;Don Trotter&quot;
    #   my_course.save
    #
    #   my_other_course = Course.new(:name =&gt; &quot;Philosophy: Reason and Being&quot;, :lecturer =&gt; &quot;Ralph Cling&quot;)
    #   my_other_course.save
    def initialize(attributes = {})
      @attributes     = {}
      @prefix_options = {}
      load(attributes)
    end

    # Returns a \clone of the resource that hasn't been assigned an +id+ yet and
    # is treated as a \new resource.
    #
    #   ryan = Person.find(1)
    #   not_ryan = ryan.clone
    #   not_ryan.new?  # =&gt; true
    #
    # Any active resource member attributes will NOT be cloned, though all other
    # attributes are.  This is to prevent the conflict between any +prefix_options+
    # that refer to the original parent resource and the newly cloned parent
    # resource that does not exist.
    #
    #   ryan = Person.find(1)
    #   ryan.address = StreetAddress.find(1, :person_id =&gt; ryan.id)
    #   ryan.hash = {:not =&gt; &quot;an ARes instance&quot;}
    #
    #   not_ryan = ryan.clone
    #   not_ryan.new?            # =&gt; true
    #   not_ryan.address         # =&gt; NoMethodError
    #   not_ryan.hash            # =&gt; {:not =&gt; &quot;an ARes instance&quot;}
    def clone
      # Clone all attributes except the pk and any nested ARes
      cloned = attributes.reject {|k,v| k == self.class.primary_key || v.is_a?(ActiveResource::Base)}.inject({}) do |attrs, (k, v)|
        attrs[k] = v.clone
        attrs
      end
      # Form the new resource - bypass initialize of resource with 'new' as that will call 'load' which
      # attempts to convert hashes into member objects and arrays into collections of objects.  We want
      # the raw objects to be cloned so we bypass load by directly setting the attributes hash.
      resource = self.class.new({})
      resource.prefix_options = self.prefix_options
      resource.send :instance_variable_set, '@attributes', cloned
      resource
    end


    # A method to determine if the resource a \new object (i.e., it has not been POSTed to the remote service yet).
    #
    # ==== Examples
    #   not_new = Computer.create(:brand =&gt; 'Apple', :make =&gt; 'MacBook', :vendor =&gt; 'MacMall')
    #   not_new.new? # =&gt; false
    #
    #   is_new = Computer.new(:brand =&gt; 'IBM', :make =&gt; 'Thinkpad', :vendor =&gt; 'IBM')
    #   is_new.new? # =&gt; true
    #
    #   is_new.save
    #   is_new.new? # =&gt; false
    #
    def new?
      id.nil?
    end
    alias :new_record? :new?

    # Gets the &lt;tt&gt;\id&lt;/tt&gt; attribute of the resource.
    def id
      attributes[self.class.primary_key]
    end

    # Sets the &lt;tt&gt;\id&lt;/tt&gt; attribute of the resource.
    def id=(id)
      attributes[self.class.primary_key] = id
    end

    # Allows Active Resource objects to be used as parameters in Action Pack URL generation.
    def to_param
      id &amp;&amp; id.to_s
    end

    # Test for equality.  Resource are equal if and only if +other+ is the same object or
    # is an instance of the same class, is not &lt;tt&gt;new?&lt;/tt&gt;, and has the same +id+.
    #
    # ==== Examples
    #   ryan = Person.create(:name =&gt; 'Ryan')
    #   jamie = Person.create(:name =&gt; 'Jamie')
    #
    #   ryan == jamie
    #   # =&gt; false (Different name attribute and id)
    #
    #   ryan_again = Person.new(:name =&gt; 'Ryan')
    #   ryan == ryan_again
    #   # =&gt; false (ryan_again is new?)
    #
    #   ryans_clone = Person.create(:name =&gt; 'Ryan')
    #   ryan == ryans_clone
    #   # =&gt; false (Different id attributes)
    #
    #   ryans_twin = Person.find(ryan.id)
    #   ryan == ryans_twin
    #   # =&gt; true
    #
    def ==(other)
      other.equal?(self) || (other.instance_of?(self.class) &amp;&amp; other.id == id &amp;&amp; other.prefix_options == prefix_options)
    end

    # Tests for equality (delegates to ==).
    def eql?(other)
      self == other
    end

    # Delegates to id in order to allow two resources of the same type and \id to work with something like:
    #   [Person.find(1), Person.find(2)] &amp; [Person.find(1), Person.find(4)] # =&gt; [Person.find(1)]
    def hash
      id.hash
    end

    # Duplicate the current resource without saving it.
    #
    # ==== Examples
    #   my_invoice = Invoice.create(:customer =&gt; 'That Company')
    #   next_invoice = my_invoice.dup
    #   next_invoice.new? # =&gt; true
    #
    #   next_invoice.save
    #   next_invoice == my_invoice # =&gt; false (different id attributes)
    #
    #   my_invoice.customer   # =&gt; That Company
    #   next_invoice.customer # =&gt; That Company
    def dup
      self.class.new.tap do |resource|
        resource.attributes     = @attributes
        resource.prefix_options = @prefix_options
      end
    end

    # A method to \save (+POST+) or \update (+PUT+) a resource.  It delegates to +create+ if a \new object, 
    # +update+ if it is existing. If the response to the \save includes a body, it will be assumed that this body
    # is XML for the final object as it looked after the \save (which would include attributes like +created_at+
    # that weren't part of the original submit).
    #
    # ==== Examples
    #   my_company = Company.new(:name =&gt; 'RoleModel Software', :owner =&gt; 'Ken Auer', :size =&gt; 2)
    #   my_company.new? # =&gt; true
    #   my_company.save # sends POST /companies/ (create)
    #
    #   my_company.new? # =&gt; false
    #   my_company.size = 10
    #   my_company.save # sends PUT /companies/1 (update)
    def save
      new? ? create : update
    end

    # Deletes the resource from the remote service.
    #
    # ==== Examples
    #   my_id = 3
    #   my_person = Person.find(my_id)
    #   my_person.destroy
    #   Person.find(my_id) # 404 (Resource Not Found)
    #
    #   new_person = Person.create(:name =&gt; 'James')
    #   new_id = new_person.id # =&gt; 7
    #   new_person.destroy
    #   Person.find(new_id) # 404 (Resource Not Found)
    def destroy
      connection.delete(element_path, self.class.headers)
    end

    # Evaluates to &lt;tt&gt;true&lt;/tt&gt; if this resource is not &lt;tt&gt;new?&lt;/tt&gt; and is
    # found on the remote service.  Using this method, you can check for
    # resources that may have been deleted between the object's instantiation
    # and actions on it.
    #
    # ==== Examples
    #   Person.create(:name =&gt; 'Theodore Roosevelt')
    #   that_guy = Person.find(:first)
    #   that_guy.exists? # =&gt; true
    #
    #   that_lady = Person.new(:name =&gt; 'Paul Bean')
    #   that_lady.exists? # =&gt; false
    #
    #   guys_id = that_guy.id
    #   Person.delete(guys_id)
    #   that_guy.exists? # =&gt; false
    def exists?
      !new? &amp;&amp; self.class.exists?(to_param, :params =&gt; prefix_options)
    end

    # A method to convert the the resource to an XML string.
    #
    # ==== Options
    # The +options+ parameter is handed off to the +to_xml+ method on each
    # attribute, so it has the same options as the +to_xml+ methods in
    # Active Support.
    #
    # * &lt;tt&gt;:indent&lt;/tt&gt; - Set the indent level for the XML output (default is +2+).
    # * &lt;tt&gt;:dasherize&lt;/tt&gt; - Boolean option to determine whether or not element names should
    #   replace underscores with dashes (default is &lt;tt&gt;false&lt;/tt&gt;).
    # * &lt;tt&gt;:skip_instruct&lt;/tt&gt; - Toggle skipping the +instruct!+ call on the XML builder
    #   that generates the XML declaration (default is &lt;tt&gt;false&lt;/tt&gt;).
    #
    # ==== Examples
    #   my_group = SubsidiaryGroup.find(:first)
    #   my_group.to_xml
    #   # =&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    #   #    &lt;subsidiary_group&gt; [...] &lt;/subsidiary_group&gt;
    #
    #   my_group.to_xml(:dasherize =&gt; true)
    #   # =&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    #   #    &lt;subsidiary-group&gt; [...] &lt;/subsidiary-group&gt;
    #
    #   my_group.to_xml(:skip_instruct =&gt; true)
    #   # =&gt; &lt;subsidiary_group&gt; [...] &lt;/subsidiary_group&gt;
    def to_xml(options={})
      attributes.to_xml({:root =&gt; self.class.element_name}.merge(options))
    end

    # Returns a JSON string representing the model. Some configuration is
    # available through +options+.
    #
    # ==== Options
    # The +options+ are passed to the +to_json+ method on each
    # attribute, so the same options as the +to_json+ methods in
    # Active Support.
    #
    # * &lt;tt&gt;:only&lt;/tt&gt; - Only include the specified attribute or list of
    #   attributes in the serialized output. Attribute names must be specified
    #   as strings.
    # * &lt;tt&gt;:except&lt;/tt&gt; - Do not include the specified attribute or list of
    #   attributes in the serialized output. Attribute names must be specified
    #   as strings.
    #
    # ==== Examples
    #   person = Person.new(:first_name =&gt; &quot;Jim&quot;, :last_name =&gt; &quot;Smith&quot;)
    #   person.to_json
    #   # =&gt; {&quot;first_name&quot;: &quot;Jim&quot;, &quot;last_name&quot;: &quot;Smith&quot;}
    #
    #   person.to_json(:only =&gt; [&quot;first_name&quot;])
    #   # =&gt; {&quot;first_name&quot;: &quot;Jim&quot;}
    #
    #   person.to_json(:except =&gt; [&quot;first_name&quot;])
    #   # =&gt; {&quot;last_name&quot;: &quot;Smith&quot;}
    def to_json(options={})
      attributes.to_json(options)
    end

    # Returns the serialized string representation of the resource in the configured
    # serialization format specified in ActiveResource::Base.format. The options
    # applicable depend on the configured encoding format.
    def encode(options={})
      case self.class.format
        when ActiveResource::Formats[:xml]
          self.class.format.encode(attributes, {:root =&gt; self.class.element_name}.merge(options))
        else
          self.class.format.encode(attributes, options)
      end
    end

    # A method to \reload the attributes of this object from the remote web service.
    #
    # ==== Examples
    #   my_branch = Branch.find(:first)
    #   my_branch.name # =&gt; &quot;Wislon Raod&quot;
    #
    #   # Another client fixes the typo...
    #
    #   my_branch.name # =&gt; &quot;Wislon Raod&quot;
    #   my_branch.reload
    #   my_branch.name # =&gt; &quot;Wilson Road&quot;
    def reload
      self.load(self.class.find(to_param, :params =&gt; @prefix_options).attributes)
    end

    # A method to manually load attributes from a \hash. Recursively loads collections of
    # resources.  This method is called in +initialize+ and +create+ when a \hash of attributes
    # is provided.
    #
    # ==== Examples
    #   my_attrs = {:name =&gt; 'J&amp;J Textiles', :industry =&gt; 'Cloth and textiles'}
    #   my_attrs = {:name =&gt; 'Marty', :colors =&gt; [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]}
    #
    #   the_supplier = Supplier.find(:first)
    #   the_supplier.name # =&gt; 'J&amp;M Textiles'
    #   the_supplier.load(my_attrs)
    #   the_supplier.name('J&amp;J Textiles')
    #
    #   # These two calls are the same as Supplier.new(my_attrs)
    #   my_supplier = Supplier.new
    #   my_supplier.load(my_attrs)
    #
    #   # These three calls are the same as Supplier.create(my_attrs)
    #   your_supplier = Supplier.new
    #   your_supplier.load(my_attrs)
    #   your_supplier.save
    def load(attributes)
      raise ArgumentError, &quot;expected an attributes Hash, got #{attributes.inspect}&quot; unless attributes.is_a?(Hash)
      @prefix_options, attributes = split_options(attributes)
      attributes.each do |key, value|
        @attributes[key.to_s] =
          case value
            when Array
              resource = find_or_create_resource_for_collection(key)
              value.map { |attrs| attrs.is_a?(String) ? attrs.dup : resource.new(attrs) }
            when Hash
              resource = find_or_create_resource_for(key)
              resource.new(value)
            else
              value.dup rescue value
          end
      end
      self
    end

    # For checking &lt;tt&gt;respond_to?&lt;/tt&gt; without searching the attributes (which is faster).
    alias_method :respond_to_without_attributes?, :respond_to?

    # A method to determine if an object responds to a message (e.g., a method call). In Active Resource, a Person object with a
    # +name+ attribute can answer &lt;tt&gt;true&lt;/tt&gt; to &lt;tt&gt;my_person.respond_to?(:name)&lt;/tt&gt;, &lt;tt&gt;my_person.respond_to?(:name=)&lt;/tt&gt;, and
    # &lt;tt&gt;my_person.respond_to?(:name?)&lt;/tt&gt;.
    def respond_to?(method, include_priv = false)
      method_name = method.to_s
      if attributes.nil?
        return super
      elsif attributes.has_key?(method_name)
        return true
      elsif ['?','='].include?(method_name.last) &amp;&amp; attributes.has_key?(method_name.first(-1))
        return true
      end
      # super must be called at the end of the method, because the inherited respond_to?
      # would return true for generated readers, even if the attribute wasn't present
      super
    end


    protected
      def connection(refresh = false)
        self.class.connection(refresh)
      end

      # Update the resource on the remote service.
      def update
        connection.put(element_path(prefix_options), encode, self.class.headers).tap do |response|
          load_attributes_from_response(response)
        end
      end

      # Create (i.e., \save to the remote service) the \new resource.
      def create
        connection.post(collection_path, encode, self.class.headers).tap do |response|
          self.id = id_from_response(response)
          load_attributes_from_response(response)
        end
      end

      def load_attributes_from_response(response)
        if response['Content-Length'] != &quot;0&quot; &amp;&amp; response.body.strip.size &gt; 0
          load(self.class.format.decode(response.body))
        end
      end

      # Takes a response from a typical create post and pulls the ID out
      def id_from_response(response)
        response['Location'][/\/([^\/]*?)(\.\w+)?$/, 1] if response['Location']
      end

      def element_path(options = nil)
        self.class.element_path(to_param, options || prefix_options)
      end

      def collection_path(options = nil)
        self.class.collection_path(options || prefix_options)
      end

    private
      # Tries to find a resource for a given collection name; if it fails, then the resource is created
      def find_or_create_resource_for_collection(name)
        find_or_create_resource_for(name.to_s.singularize)
      end

      # Tries to find a resource in a non empty list of nested modules
      # Raises a NameError if it was not found in any of the given nested modules
      def find_resource_in_modules(resource_name, module_names)
        receiver = Object
        namespaces = module_names[0, module_names.size-1].map do |module_name|
          receiver = receiver.const_get(module_name)
        end
        if namespace = namespaces.reverse.detect { |ns| ns.const_defined?(resource_name) }
          return namespace.const_get(resource_name)
        else
          raise NameError
        end
      end

      # Tries to find a resource for a given name; if it fails, then the resource is created
      def find_or_create_resource_for(name)
        resource_name = name.to_s.camelize
        ancestors = self.class.name.split(&quot;::&quot;)
        if ancestors.size &gt; 1
          find_resource_in_modules(resource_name, ancestors)
        else
          self.class.const_get(resource_name)
        end
      rescue NameError
        if self.class.const_defined?(resource_name)
          resource = self.class.const_get(resource_name)
        else
          resource = self.class.const_set(resource_name, Class.new(ActiveResource::Base))
        end
        resource.prefix = self.class.prefix
        resource.site   = self.class.site
        resource
      end

      def split_options(options = {})
        self.class.__send__(:split_options, options)
      end

      def method_missing(method_symbol, *arguments) #:nodoc:
        method_name = method_symbol.to_s

        case method_name.last
          when &quot;=&quot;
            attributes[method_name.first(-1)] = arguments.first
          when &quot;?&quot;
            attributes[method_name.first(-1)]
          else
            attributes.has_key?(method_name) ? attributes[method_name] : super
        end
      end
  end
end
</pre>
    </div>
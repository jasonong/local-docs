  <div id="fileHeader">
    <h1>routing_assertions.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>rails-2.3.2/actionpack/lib/action_controller/assertions/routing_assertions.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Mar 15 23:31:32 -0500 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActionController
  module Assertions
    # Suite of assertions to test routes generated by Rails and the handling of requests made to them.
    module RoutingAssertions
      # Asserts that the routing of the given +path+ was handled correctly and that the parsed options (given in the +expected_options+ hash)
      # match +path+.  Basically, it asserts that Rails recognizes the route given by +expected_options+.
      #
      # Pass a hash in the second argument (+path+) to specify the request method.  This is useful for routes
      # requiring a specific HTTP method.  The hash should contain a :path with the incoming request path
      # and a :method containing the required HTTP verb.
      #
      #   # assert that POSTing to /items will call the create action on ItemsController
      #   assert_recognizes {:controller =&gt; 'items', :action =&gt; 'create'}, {:path =&gt; 'items', :method =&gt; :post}
      #
      # You can also pass in +extras+ with a hash containing URL parameters that would normally be in the query string.  This can be used
      # to assert that values in the query string string will end up in the params hash correctly.  To test query strings you must use the
      # extras argument, appending the query string on the path directly will not work.  For example:
      #
      #   # assert that a path of '/items/list/1?view=print' returns the correct options
      #   assert_recognizes {:controller =&gt; 'items', :action =&gt; 'list', :id =&gt; '1', :view =&gt; 'print'}, 'items/list/1', { :view =&gt; &quot;print&quot; }
      #
      # The +message+ parameter allows you to pass in an error message that is displayed upon failure.
      #
      # ==== Examples
      #   # Check the default route (i.e., the index action)
      #   assert_recognizes {:controller =&gt; 'items', :action =&gt; 'index'}, 'items'
      #
      #   # Test a specific action
      #   assert_recognizes {:controller =&gt; 'items', :action =&gt; 'list'}, 'items/list'
      #
      #   # Test an action with a parameter
      #   assert_recognizes {:controller =&gt; 'items', :action =&gt; 'destroy', :id =&gt; '1'}, 'items/destroy/1'
      #
      #   # Test a custom route
      #   assert_recognizes {:controller =&gt; 'items', :action =&gt; 'show', :id =&gt; '1'}, 'view/item1'
      #
      #   # Check a Simply RESTful generated route
      #   assert_recognizes list_items_url, 'items/list'
      def assert_recognizes(expected_options, path, extras={}, message=nil)
        if path.is_a? Hash
          request_method = path[:method]
          path           = path[:path]
        else
          request_method = nil
        end

        clean_backtrace do
          ActionController::Routing::Routes.reload if ActionController::Routing::Routes.empty?
          request = recognized_request_for(path, request_method)

          expected_options = expected_options.clone
          extras.each_key { |key| expected_options.delete key } unless extras.nil?

          expected_options.stringify_keys!
          routing_diff = expected_options.diff(request.path_parameters)
          msg = build_message(message, &quot;The recognized options &lt;?&gt; did not match &lt;?&gt;, difference: &lt;?&gt;&quot;,
              request.path_parameters, expected_options, expected_options.diff(request.path_parameters))
          assert_block(msg) { request.path_parameters == expected_options }
        end
      end

      # Asserts that the provided options can be used to generate the provided path.  This is the inverse of +assert_recognizes+.
      # The +extras+ parameter is used to tell the request the names and values of additional request parameters that would be in
      # a query string. The +message+ parameter allows you to specify a custom error message for assertion failures.
      #
      # The +defaults+ parameter is unused.
      #
      # ==== Examples
      #   # Asserts that the default action is generated for a route with no action
      #   assert_generates &quot;/items&quot;, :controller =&gt; &quot;items&quot;, :action =&gt; &quot;index&quot;
      #
      #   # Tests that the list action is properly routed
      #   assert_generates &quot;/items/list&quot;, :controller =&gt; &quot;items&quot;, :action =&gt; &quot;list&quot;
      #
      #   # Tests the generation of a route with a parameter
      #   assert_generates &quot;/items/list/1&quot;, { :controller =&gt; &quot;items&quot;, :action =&gt; &quot;list&quot;, :id =&gt; &quot;1&quot; }
      #
      #   # Asserts that the generated route gives us our custom route
      #   assert_generates &quot;changesets/12&quot;, { :controller =&gt; 'scm', :action =&gt; 'show_diff', :revision =&gt; &quot;12&quot; }
      def assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)
        clean_backtrace do
          expected_path = &quot;/#{expected_path}&quot; unless expected_path[0] == ?/
          # Load routes.rb if it hasn't been loaded.
          ActionController::Routing::Routes.reload if ActionController::Routing::Routes.empty?

          generated_path, extra_keys = ActionController::Routing::Routes.generate_extras(options, defaults)
          found_extras = options.reject {|k, v| ! extra_keys.include? k}

          msg = build_message(message, &quot;found extras &lt;?&gt;, not &lt;?&gt;&quot;, found_extras, extras)
          assert_block(msg) { found_extras == extras }

          msg = build_message(message, &quot;The generated path &lt;?&gt; did not match &lt;?&gt;&quot;, generated_path,
              expected_path)
          assert_block(msg) { expected_path == generated_path }
        end
      end

      # Asserts that path and options match both ways; in other words, it verifies that &lt;tt&gt;path&lt;/tt&gt; generates
      # &lt;tt&gt;options&lt;/tt&gt; and then that &lt;tt&gt;options&lt;/tt&gt; generates &lt;tt&gt;path&lt;/tt&gt;.  This essentially combines +assert_recognizes+
      # and +assert_generates+ into one step.
      #
      # The +extras+ hash allows you to specify options that would normally be provided as a query string to the action.  The
      # +message+ parameter allows you to specify a custom error message to display upon failure.
      #
      # ==== Examples
      #  # Assert a basic route: a controller with the default action (index)
      #  assert_routing '/home', :controller =&gt; 'home', :action =&gt; 'index'
      #
      #  # Test a route generated with a specific controller, action, and parameter (id)
      #  assert_routing '/entries/show/23', :controller =&gt; 'entries', :action =&gt; 'show', id =&gt; 23
      #
      #  # Assert a basic route (controller + default action), with an error message if it fails
      #  assert_routing '/store', { :controller =&gt; 'store', :action =&gt; 'index' }, {}, {}, 'Route for store index not generated properly'
      #
      #  # Tests a route, providing a defaults hash
      #  assert_routing 'controller/action/9', {:id =&gt; &quot;9&quot;, :item =&gt; &quot;square&quot;}, {:controller =&gt; &quot;controller&quot;, :action =&gt; &quot;action&quot;}, {}, {:item =&gt; &quot;square&quot;}
      #
      #  # Tests a route with a HTTP method
      #  assert_routing { :method =&gt; 'put', :path =&gt; '/product/321' }, { :controller =&gt; &quot;product&quot;, :action =&gt; &quot;update&quot;, :id =&gt; &quot;321&quot; }
      def assert_routing(path, options, defaults={}, extras={}, message=nil)
        assert_recognizes(options, path, extras, message)

        controller, default_controller = options[:controller], defaults[:controller]
        if controller &amp;&amp; controller.include?(?/) &amp;&amp; default_controller &amp;&amp; default_controller.include?(?/)
          options[:controller] = &quot;/#{controller}&quot;
        end

        assert_generates(path.is_a?(Hash) ? path[:path] : path, options, defaults, extras, message)
      end

      private
        # Recognizes the route for a given path.
        def recognized_request_for(path, request_method = nil)
          path = &quot;/#{path}&quot; unless path.first == '/'

          # Assume given controller
          request = ActionController::TestRequest.new
          request.env[&quot;REQUEST_METHOD&quot;] = request_method.to_s.upcase if request_method
          request.path   = path

          ActionController::Routing::Routes.recognize(request)
          request
        end
    end
  end
end
</pre>
    </div>
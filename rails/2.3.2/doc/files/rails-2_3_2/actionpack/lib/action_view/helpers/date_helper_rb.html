  <div id="fileHeader">
    <h1>date_helper.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>rails-2.3.2/actionpack/lib/action_view/helpers/date_helper.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Mar 15 23:31:32 -0500 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;date&quot;
require 'action_view/helpers/tag_helper'

module ActionView
  module Helpers
    # The Date Helper primarily creates select/option tags for different kinds of dates and date elements. All of the
    # select-type methods share a number of common options that are as follows:
    #
    # * &lt;tt&gt;:prefix&lt;/tt&gt; - overwrites the default prefix of &quot;date&quot; used for the select names. So specifying &quot;birthday&quot;
    # would give birthday[month] instead of date[month] if passed to the select_month method.
    # * &lt;tt&gt;:include_blank&lt;/tt&gt; - set to true if it should be possible to set an empty date.
    # * &lt;tt&gt;:discard_type&lt;/tt&gt; - set to true if you want to discard the type part of the select name. If set to true,
    #   the select_month method would use simply &quot;date&quot; (which can be overwritten using &lt;tt&gt;:prefix&lt;/tt&gt;) instead of
    #   &quot;date[month]&quot;.
    module DateHelper
      # Reports the approximate distance in time between two Time or Date objects or integers as seconds.
      # Set &lt;tt&gt;include_seconds&lt;/tt&gt; to true if you want more detailed approximations when distance &lt; 1 min, 29 secs
      # Distances are reported based on the following table:
      #
      #   0 &lt;-&gt; 29 secs                                                             # =&gt; less than a minute
      #   30 secs &lt;-&gt; 1 min, 29 secs                                                # =&gt; 1 minute
      #   1 min, 30 secs &lt;-&gt; 44 mins, 29 secs                                       # =&gt; [2..44] minutes
      #   44 mins, 30 secs &lt;-&gt; 89 mins, 29 secs                                     # =&gt; about 1 hour
      #   89 mins, 29 secs &lt;-&gt; 23 hrs, 59 mins, 29 secs                             # =&gt; about [2..24] hours
      #   23 hrs, 59 mins, 29 secs &lt;-&gt; 47 hrs, 59 mins, 29 secs                     # =&gt; 1 day
      #   47 hrs, 59 mins, 29 secs &lt;-&gt; 29 days, 23 hrs, 59 mins, 29 secs            # =&gt; [2..29] days
      #   29 days, 23 hrs, 59 mins, 30 secs &lt;-&gt; 59 days, 23 hrs, 59 mins, 29 secs   # =&gt; about 1 month
      #   59 days, 23 hrs, 59 mins, 30 secs &lt;-&gt; 1 yr minus 1 sec                    # =&gt; [2..12] months
      #   1 yr &lt;-&gt; 2 yrs minus 1 secs                                               # =&gt; about 1 year
      #   2 yrs &lt;-&gt; max time or date                                                # =&gt; over [2..X] years
      #
      # With &lt;tt&gt;include_seconds&lt;/tt&gt; = true and the difference &lt; 1 minute 29 seconds:
      #   0-4   secs      # =&gt; less than 5 seconds
      #   5-9   secs      # =&gt; less than 10 seconds
      #   10-19 secs      # =&gt; less than 20 seconds
      #   20-39 secs      # =&gt; half a minute
      #   40-59 secs      # =&gt; less than a minute
      #   60-89 secs      # =&gt; 1 minute
      #
      # ==== Examples
      #   from_time = Time.now
      #   distance_of_time_in_words(from_time, from_time + 50.minutes)        # =&gt; about 1 hour
      #   distance_of_time_in_words(from_time, 50.minutes.from_now)           # =&gt; about 1 hour
      #   distance_of_time_in_words(from_time, from_time + 15.seconds)        # =&gt; less than a minute
      #   distance_of_time_in_words(from_time, from_time + 15.seconds, true)  # =&gt; less than 20 seconds
      #   distance_of_time_in_words(from_time, 3.years.from_now)              # =&gt; over 3 years
      #   distance_of_time_in_words(from_time, from_time + 60.hours)          # =&gt; about 3 days
      #   distance_of_time_in_words(from_time, from_time + 45.seconds, true)  # =&gt; less than a minute
      #   distance_of_time_in_words(from_time, from_time - 45.seconds, true)  # =&gt; less than a minute
      #   distance_of_time_in_words(from_time, 76.seconds.from_now)           # =&gt; 1 minute
      #   distance_of_time_in_words(from_time, from_time + 1.year + 3.days)   # =&gt; about 1 year
      #   distance_of_time_in_words(from_time, from_time + 4.years + 9.days + 30.minutes + 5.seconds) # =&gt; over 4 years
      #
      #   to_time = Time.now + 6.years + 19.days
      #   distance_of_time_in_words(from_time, to_time, true)     # =&gt; over 6 years
      #   distance_of_time_in_words(to_time, from_time, true)     # =&gt; over 6 years
      #   distance_of_time_in_words(Time.now, Time.now)           # =&gt; less than a minute
      #
      def distance_of_time_in_words(from_time, to_time = 0, include_seconds = false, options = {})
        from_time = from_time.to_time if from_time.respond_to?(:to_time)
        to_time = to_time.to_time if to_time.respond_to?(:to_time)
        distance_in_minutes = (((to_time - from_time).abs)/60).round
        distance_in_seconds = ((to_time - from_time).abs).round

        I18n.with_options :locale =&gt; options[:locale], :scope =&gt; :'datetime.distance_in_words' do |locale|
          case distance_in_minutes
            when 0..1
              return distance_in_minutes == 0 ?
                     locale.t(:less_than_x_minutes, :count =&gt; 1) :
                     locale.t(:x_minutes, :count =&gt; distance_in_minutes) unless include_seconds

              case distance_in_seconds
                when 0..4   then locale.t :less_than_x_seconds, :count =&gt; 5
                when 5..9   then locale.t :less_than_x_seconds, :count =&gt; 10
                when 10..19 then locale.t :less_than_x_seconds, :count =&gt; 20
                when 20..39 then locale.t :half_a_minute
                when 40..59 then locale.t :less_than_x_minutes, :count =&gt; 1
                else             locale.t :x_minutes,           :count =&gt; 1
              end

            when 2..44           then locale.t :x_minutes,      :count =&gt; distance_in_minutes
            when 45..89          then locale.t :about_x_hours,  :count =&gt; 1
            when 90..1439        then locale.t :about_x_hours,  :count =&gt; (distance_in_minutes.to_f / 60.0).round
            when 1440..2879      then locale.t :x_days,         :count =&gt; 1
            when 2880..43199     then locale.t :x_days,         :count =&gt; (distance_in_minutes / 1440).round
            when 43200..86399    then locale.t :about_x_months, :count =&gt; 1
            when 86400..525599   then locale.t :x_months,       :count =&gt; (distance_in_minutes / 43200).round
            when 525600..1051199 then locale.t :about_x_years,  :count =&gt; 1
            else                      locale.t :over_x_years,   :count =&gt; (distance_in_minutes / 525600).round
          end
        end
      end

      # Like distance_of_time_in_words, but where &lt;tt&gt;to_time&lt;/tt&gt; is fixed to &lt;tt&gt;Time.now&lt;/tt&gt;.
      #
      # ==== Examples
      #   time_ago_in_words(3.minutes.from_now)       # =&gt; 3 minutes
      #   time_ago_in_words(Time.now - 15.hours)      # =&gt; 15 hours
      #   time_ago_in_words(Time.now)                 # =&gt; less than a minute
      #
      #   from_time = Time.now - 3.days - 14.minutes - 25.seconds     # =&gt; 3 days
      def time_ago_in_words(from_time, include_seconds = false)
        distance_of_time_in_words(from_time, Time.now, include_seconds)
      end

      alias_method :distance_of_time_in_words_to_now, :time_ago_in_words

      # Returns a set of select tags (one for year, month, and day) pre-selected for accessing a specified date-based
      # attribute (identified by +method+) on an object assigned to the template (identified by +object+). You can
      # the output in the +options+ hash.
      #
      # ==== Options
      # * &lt;tt&gt;:use_month_numbers&lt;/tt&gt; - Set to true if you want to use month numbers rather than month names (e.g.
      #   &quot;2&quot; instead of &quot;February&quot;).
      # * &lt;tt&gt;:use_short_month&lt;/tt&gt;   - Set to true if you want to use the abbreviated month name instead of the full
      #   name (e.g. &quot;Feb&quot; instead of &quot;February&quot;).
      # * &lt;tt&gt;:add_month_number&lt;/tt&gt;  - Set to true if you want to show both, the month's number and name (e.g.
      #   &quot;2 - February&quot; instead of &quot;February&quot;).
      # * &lt;tt&gt;:use_month_names&lt;/tt&gt;   - Set to an array with 12 month names if you want to customize month names.
      #   Note: You can also use Rails' new i18n functionality for this.
      # * &lt;tt&gt;:date_separator&lt;/tt&gt;    - Specifies a string to separate the date fields. Default is &quot;&quot; (i.e. nothing).
      # * &lt;tt&gt;:start_year&lt;/tt&gt;        - Set the start year for the year select. Default is &lt;tt&gt;Time.now.year - 5&lt;/tt&gt;.
      # * &lt;tt&gt;:end_year&lt;/tt&gt;          - Set the end year for the year select. Default is &lt;tt&gt;Time.now.year + 5&lt;/tt&gt;.
      # * &lt;tt&gt;:discard_day&lt;/tt&gt;       - Set to true if you don't want to show a day select. This includes the day
      #   as a hidden field instead of showing a select field. Also note that this implicitly sets the day to be the
      #   first of the given month in order to not create invalid dates like 31 February.
      # * &lt;tt&gt;:discard_month&lt;/tt&gt;     - Set to true if you don't want to show a month select. This includes the month
      #   as a hidden field instead of showing a select field. Also note that this implicitly sets :discard_day to true.
      # * &lt;tt&gt;:discard_year&lt;/tt&gt;      - Set to true if you don't want to show a year select. This includes the year
      #   as a hidden field instead of showing a select field.
      # * &lt;tt&gt;:order&lt;/tt&gt;             - Set to an array containing &lt;tt&gt;:day&lt;/tt&gt;, &lt;tt&gt;:month&lt;/tt&gt; and &lt;tt&gt;:year&lt;/tt&gt; do
      #   customize the order in which the select fields are shown. If you leave out any of the symbols, the respective
      #   select will not be shown (like when you set &lt;tt&gt;:discard_xxx =&gt; true&lt;/tt&gt;. Defaults to the order defined in
      #   the respective locale (e.g. [:year, :month, :day] in the en locale that ships with Rails).
      # * &lt;tt&gt;:include_blank&lt;/tt&gt;     - Include a blank option in every select field so it's possible to set empty
      #   dates.
      # * &lt;tt&gt;:default&lt;/tt&gt;           - Set a default date if the affected date isn't set or is nil.
      # * &lt;tt&gt;:disabled&lt;/tt&gt;          - Set to true if you want show the select fields as disabled.
      # * &lt;tt&gt;:prompt&lt;/tt&gt;            - Set to true (for a generic prompt), a prompt string or a hash of prompt strings
      #   for &lt;tt&gt;:year&lt;/tt&gt;, &lt;tt&gt;:month&lt;/tt&gt;, &lt;tt&gt;:day&lt;/tt&gt;, &lt;tt&gt;:hour&lt;/tt&gt;, &lt;tt&gt;:minute&lt;/tt&gt; and &lt;tt&gt;:second&lt;/tt&gt;.
      #   Setting this option prepends a select option with a generic prompt  (Day, Month, Year, Hour, Minute, Seconds)
      #   or the given prompt string.
      #
      # If anything is passed in the +html_options+ hash it will be applied to every select tag in the set.
      #
      # NOTE: Discarded selects will default to 1. So if no month select is available, January will be assumed.
      #
      # ==== Examples
      #   # Generates a date select that when POSTed is stored in the post variable, in the written_on attribute
      #   date_select(&quot;post&quot;, &quot;written_on&quot;)
      #
      #   # Generates a date select that when POSTed is stored in the post variable, in the written_on attribute,
      #   # with the year in the year drop down box starting at 1995.
      #   date_select(&quot;post&quot;, &quot;written_on&quot;, :start_year =&gt; 1995)
      #
      #   # Generates a date select that when POSTed is stored in the post variable, in the written_on attribute,
      #   # with the year in the year drop down box starting at 1995, numbers used for months instead of words,
      #   # and without a day select box.
      #   date_select(&quot;post&quot;, &quot;written_on&quot;, :start_year =&gt; 1995, :use_month_numbers =&gt; true,
      #                                     :discard_day =&gt; true, :include_blank =&gt; true)
      #
      #   # Generates a date select that when POSTed is stored in the post variable, in the written_on attribute
      #   # with the fields ordered as day, month, year rather than month, day, year.
      #   date_select(&quot;post&quot;, &quot;written_on&quot;, :order =&gt; [:day, :month, :year])
      #
      #   # Generates a date select that when POSTed is stored in the user variable, in the birthday attribute
      #   # lacking a year field.
      #   date_select(&quot;user&quot;, &quot;birthday&quot;, :order =&gt; [:month, :day])
      #
      #   # Generates a date select that when POSTed is stored in the user variable, in the birthday attribute
      #   # which is initially set to the date 3 days from the current date
      #   date_select(&quot;post&quot;, &quot;written_on&quot;, :default =&gt; 3.days.from_now)
      #
      #   # Generates a date select that when POSTed is stored in the credit_card variable, in the bill_due attribute
      #   # that will have a default day of 20.
      #   date_select(&quot;credit_card&quot;, &quot;bill_due&quot;, :default =&gt; { :day =&gt; 20 })
      #
      #   # Generates a date select with custom prompts
      #   date_select(&quot;post&quot;, &quot;written_on&quot;, :prompt =&gt; { :day =&gt; 'Select day', :month =&gt; 'Select month', :year =&gt; 'Select year' })
      #
      # The selects are prepared for multi-parameter assignment to an Active Record object.
      #
      # Note: If the day is not included as an option but the month is, the day will be set to the 1st to ensure that
      # all month choices are valid.
      def date_select(object_name, method, options = {}, html_options = {})
        InstanceTag.new(object_name, method, self, options.delete(:object)).to_date_select_tag(options, html_options)
      end

      # Returns a set of select tags (one for hour, minute and optionally second) pre-selected for accessing a
      # specified time-based attribute (identified by +method+) on an object assigned to the template (identified by
      # +object+). You can include the seconds with &lt;tt&gt;:include_seconds&lt;/tt&gt;.
      #
      # This method will also generate 3 input hidden tags, for the actual year, month and day unless the option
      # &lt;tt&gt;:ignore_date&lt;/tt&gt; is set to +true+.
      #
      # If anything is passed in the html_options hash it will be applied to every select tag in the set.
      #
      # ==== Examples
      #   # Creates a time select tag that, when POSTed, will be stored in the post variable in the sunrise attribute
      #   time_select(&quot;post&quot;, &quot;sunrise&quot;)
      #
      #   # Creates a time select tag that, when POSTed, will be stored in the order variable in the submitted
      #   # attribute
      #   time_select(&quot;order&quot;, &quot;submitted&quot;)
      #
      #   # Creates a time select tag that, when POSTed, will be stored in the mail variable in the sent_at attribute
      #   time_select(&quot;mail&quot;, &quot;sent_at&quot;)
      #
      #   # Creates a time select tag with a seconds field that, when POSTed, will be stored in the post variables in
      #   # the sunrise attribute.
      #   time_select(&quot;post&quot;, &quot;start_time&quot;, :include_seconds =&gt; true)
      #
      #   # Creates a time select tag with a seconds field that, when POSTed, will be stored in the entry variables in
      #   # the submission_time attribute.
      #   time_select(&quot;entry&quot;, &quot;submission_time&quot;, :include_seconds =&gt; true)
      #
      #   # You can set the :minute_step to 15 which will give you: 00, 15, 30 and 45.
      #   time_select 'game', 'game_time', {:minute_step =&gt; 15}
      #
      #   # Creates a time select tag with a custom prompt. Use :prompt =&gt; true for generic prompts.
      #   time_select(&quot;post&quot;, &quot;written_on&quot;, :prompt =&gt; {:hour =&gt; 'Choose hour', :minute =&gt; 'Choose minute', :second =&gt; 'Choose seconds'})
      #   time_select(&quot;post&quot;, &quot;written_on&quot;, :prompt =&gt; {:hour =&gt; true}) # generic prompt for hours
      #   time_select(&quot;post&quot;, &quot;written_on&quot;, :prompt =&gt; true) # generic prompts for all
      #
      # The selects are prepared for multi-parameter assignment to an Active Record object.
      #
      # Note: If the day is not included as an option but the month is, the day will be set to the 1st to ensure that
      # all month choices are valid.
      def time_select(object_name, method, options = {}, html_options = {})
        InstanceTag.new(object_name, method, self, options.delete(:object)).to_time_select_tag(options, html_options)
      end

      # Returns a set of select tags (one for year, month, day, hour, and minute) pre-selected for accessing a
      # specified datetime-based attribute (identified by +method+) on an object assigned to the template (identified
      # by +object+). Examples:
      #
      # If anything is passed in the html_options hash it will be applied to every select tag in the set.
      #
      # ==== Examples
      #   # Generates a datetime select that, when POSTed, will be stored in the post variable in the written_on
      #   # attribute
      #   datetime_select(&quot;post&quot;, &quot;written_on&quot;)
      #
      #   # Generates a datetime select with a year select that starts at 1995 that, when POSTed, will be stored in the
      #   # post variable in the written_on attribute.
      #   datetime_select(&quot;post&quot;, &quot;written_on&quot;, :start_year =&gt; 1995)
      #
      #   # Generates a datetime select with a default value of 3 days from the current time that, when POSTed, will
      #   # be stored in the trip variable in the departing attribute.
      #   datetime_select(&quot;trip&quot;, &quot;departing&quot;, :default =&gt; 3.days.from_now)
      #
      #   # Generates a datetime select that discards the type that, when POSTed, will be stored in the post variable
      #   # as the written_on attribute.
      #   datetime_select(&quot;post&quot;, &quot;written_on&quot;, :discard_type =&gt; true)
      #
      #   # Generates a datetime select with a custom prompt. Use :prompt=&gt;true for generic prompts.
      #   datetime_select(&quot;post&quot;, &quot;written_on&quot;, :prompt =&gt; {:day =&gt; 'Choose day', :month =&gt; 'Choose month', :year =&gt; 'Choose year'})
      #   datetime_select(&quot;post&quot;, &quot;written_on&quot;, :prompt =&gt; {:hour =&gt; true}) # generic prompt for hours
      #   datetime_select(&quot;post&quot;, &quot;written_on&quot;, :prompt =&gt; true) # generic prompts for all
      #
      # The selects are prepared for multi-parameter assignment to an Active Record object.
      def datetime_select(object_name, method, options = {}, html_options = {})
        InstanceTag.new(object_name, method, self, options.delete(:object)).to_datetime_select_tag(options, html_options)
      end

      # Returns a set of html select-tags (one for year, month, day, hour, and minute) pre-selected with the
      # +datetime+. It's also possible to explicitly set the order of the tags using the &lt;tt&gt;:order&lt;/tt&gt; option with
      # an array of symbols &lt;tt&gt;:year&lt;/tt&gt;, &lt;tt&gt;:month&lt;/tt&gt; and &lt;tt&gt;:day&lt;/tt&gt; in the desired order. If you do not
      # supply a Symbol, it will be appended onto the &lt;tt&gt;:order&lt;/tt&gt; passed in. You can also add
      # &lt;tt&gt;:date_separator&lt;/tt&gt;, &lt;tt&gt;:datetime_separator&lt;/tt&gt; and &lt;tt&gt;:time_separator&lt;/tt&gt; keys to the +options+ to
      # control visual display of the elements.
      #
      # If anything is passed in the html_options hash it will be applied to every select tag in the set.
      #
      # ==== Examples
      #   my_date_time = Time.now + 4.days
      #
      #   # Generates a datetime select that defaults to the datetime in my_date_time (four days after today)
      #   select_datetime(my_date_time)
      #
      #   # Generates a datetime select that defaults to today (no specified datetime)
      #   select_datetime()
      #
      #   # Generates a datetime select that defaults to the datetime in my_date_time (four days after today)
      #   # with the fields ordered year, month, day rather than month, day, year.
      #   select_datetime(my_date_time, :order =&gt; [:year, :month, :day])
      #
      #   # Generates a datetime select that defaults to the datetime in my_date_time (four days after today)
      #   # with a '/' between each date field.
      #   select_datetime(my_date_time, :date_separator =&gt; '/')
      #
      #   # Generates a datetime select that defaults to the datetime in my_date_time (four days after today)
      #   # with a date fields separated by '/', time fields separated by '' and the date and time fields
      #   # separated by a comma (',').
      #   select_datetime(my_date_time, :date_separator =&gt; '/', :time_separator =&gt; '', :datetime_separator =&gt; ',')
      #
      #   # Generates a datetime select that discards the type of the field and defaults to the datetime in
      #   # my_date_time (four days after today)
      #   select_datetime(my_date_time, :discard_type =&gt; true)
      #
      #   # Generates a datetime select that defaults to the datetime in my_date_time (four days after today)
      #   # prefixed with 'payday' rather than 'date'
      #   select_datetime(my_date_time, :prefix =&gt; 'payday')
      #
      #   # Generates a datetime select with a custom prompt. Use :prompt=&gt;true for generic prompts.
      #   select_datetime(my_date_time, :prompt =&gt; {:day =&gt; 'Choose day', :month =&gt; 'Choose month', :year =&gt; 'Choose year'})
      #   select_datetime(my_date_time, :prompt =&gt; {:hour =&gt; true}) # generic prompt for hours
      #   select_datetime(my_date_time, :prompt =&gt; true) # generic prompts for all
      #
      def select_datetime(datetime = Time.current, options = {}, html_options = {})
        DateTimeSelector.new(datetime, options, html_options).select_datetime
      end

      # Returns a set of html select-tags (one for year, month, and day) pre-selected with the +date+.
      # It's possible to explicitly set the order of the tags using the &lt;tt&gt;:order&lt;/tt&gt; option with an array of
      # symbols &lt;tt&gt;:year&lt;/tt&gt;, &lt;tt&gt;:month&lt;/tt&gt; and &lt;tt&gt;:day&lt;/tt&gt; in the desired order. If you do not supply a Symbol,
      # it will be appended onto the &lt;tt&gt;:order&lt;/tt&gt; passed in.
      #
      # If anything is passed in the html_options hash it will be applied to every select tag in the set.
      #
      # ==== Examples
      #   my_date = Time.today + 6.days
      #
      #   # Generates a date select that defaults to the date in my_date (six days after today)
      #   select_date(my_date)
      #
      #   # Generates a date select that defaults to today (no specified date)
      #   select_date()
      #
      #   # Generates a date select that defaults to the date in my_date (six days after today)
      #   # with the fields ordered year, month, day rather than month, day, year.
      #   select_date(my_date, :order =&gt; [:year, :month, :day])
      #
      #   # Generates a date select that discards the type of the field and defaults to the date in
      #   # my_date (six days after today)
      #   select_date(my_date, :discard_type =&gt; true)
      #
      #   # Generates a date select that defaults to the date in my_date,
      #   # which has fields separated by '/'
      #   select_date(my_date, :date_separator =&gt; '/')
      #
      #   # Generates a date select that defaults to the datetime in my_date (six days after today)
      #   # prefixed with 'payday' rather than 'date'
      #   select_date(my_date, :prefix =&gt; 'payday')
      #
      #   # Generates a date select with a custom prompt. Use :prompt=&gt;true for generic prompts.
      #   select_date(my_date, :prompt =&gt; {:day =&gt; 'Choose day', :month =&gt; 'Choose month', :year =&gt; 'Choose year'})
      #   select_date(my_date, :prompt =&gt; {:hour =&gt; true}) # generic prompt for hours
      #   select_date(my_date, :prompt =&gt; true) # generic prompts for all
      #
      def select_date(date = Date.current, options = {}, html_options = {})
        DateTimeSelector.new(date, options, html_options).select_date
      end

      # Returns a set of html select-tags (one for hour and minute)
      # You can set &lt;tt&gt;:time_separator&lt;/tt&gt; key to format the output, and
      # the &lt;tt&gt;:include_seconds&lt;/tt&gt; option to include an input for seconds.
      #
      # If anything is passed in the html_options hash it will be applied to every select tag in the set.
      #
      # ==== Examples
      #   my_time = Time.now + 5.days + 7.hours + 3.minutes + 14.seconds
      #
      #   # Generates a time select that defaults to the time in my_time
      #   select_time(my_time)
      #
      #   # Generates a time select that defaults to the current time (no specified time)
      #   select_time()
      #
      #   # Generates a time select that defaults to the time in my_time,
      #   # which has fields separated by ':'
      #   select_time(my_time, :time_separator =&gt; ':')
      #
      #   # Generates a time select that defaults to the time in my_time,
      #   # that also includes an input for seconds
      #   select_time(my_time, :include_seconds =&gt; true)
      #
      #   # Generates a time select that defaults to the time in my_time, that has fields
      #   # separated by ':' and includes an input for seconds
      #   select_time(my_time, :time_separator =&gt; ':', :include_seconds =&gt; true)
      #
      #   # Generates a time select with a custom prompt. Use :prompt=&gt;true for generic prompts.
      #   select_time(my_time, :prompt =&gt; {:day =&gt; 'Choose day', :month =&gt; 'Choose month', :year =&gt; 'Choose year'})
      #   select_time(my_time, :prompt =&gt; {:hour =&gt; true}) # generic prompt for hours
      #   select_time(my_time, :prompt =&gt; true) # generic prompts for all
      #
      def select_time(datetime = Time.current, options = {}, html_options = {})
        DateTimeSelector.new(datetime, options, html_options).select_time
      end

      # Returns a select tag with options for each of the seconds 0 through 59 with the current second selected.
      # The &lt;tt&gt;second&lt;/tt&gt; can also be substituted for a second number.
      # Override the field name using the &lt;tt&gt;:field_name&lt;/tt&gt; option, 'second' by default.
      #
      # ==== Examples
      #   my_time = Time.now + 16.minutes
      #
      #   # Generates a select field for seconds that defaults to the seconds for the time in my_time
      #   select_second(my_time)
      #
      #   # Generates a select field for seconds that defaults to the number given
      #   select_second(33)
      #
      #   # Generates a select field for seconds that defaults to the seconds for the time in my_time
      #   # that is named 'interval' rather than 'second'
      #   select_second(my_time, :field_name =&gt; 'interval')
      #
      #   # Generates a select field for seconds with a custom prompt.  Use :prompt=&gt;true for a
      #   # generic prompt.
      #   select_minute(14, :prompt =&gt; 'Choose seconds')
      #
      def select_second(datetime, options = {}, html_options = {})
        DateTimeSelector.new(datetime, options, html_options).select_second
      end

      # Returns a select tag with options for each of the minutes 0 through 59 with the current minute selected.
      # Also can return a select tag with options by &lt;tt&gt;minute_step&lt;/tt&gt; from 0 through 59 with the 00 minute
      # selected. The &lt;tt&gt;minute&lt;/tt&gt; can also be substituted for a minute number.
      # Override the field name using the &lt;tt&gt;:field_name&lt;/tt&gt; option, 'minute' by default.
      #
      # ==== Examples
      #   my_time = Time.now + 6.hours
      #
      #   # Generates a select field for minutes that defaults to the minutes for the time in my_time
      #   select_minute(my_time)
      #
      #   # Generates a select field for minutes that defaults to the number given
      #   select_minute(14)
      #
      #   # Generates a select field for minutes that defaults to the minutes for the time in my_time
      #   # that is named 'stride' rather than 'second'
      #   select_minute(my_time, :field_name =&gt; 'stride')
      #
      #   # Generates a select field for minutes with a custom prompt.  Use :prompt=&gt;true for a
      #   # generic prompt.
      #   select_minute(14, :prompt =&gt; 'Choose minutes')
      #
      def select_minute(datetime, options = {}, html_options = {})
        DateTimeSelector.new(datetime, options, html_options).select_minute
      end

      # Returns a select tag with options for each of the hours 0 through 23 with the current hour selected.
      # The &lt;tt&gt;hour&lt;/tt&gt; can also be substituted for a hour number.
      # Override the field name using the &lt;tt&gt;:field_name&lt;/tt&gt; option, 'hour' by default.
      #
      # ==== Examples
      #   my_time = Time.now + 6.hours
      #
      #   # Generates a select field for hours that defaults to the hour for the time in my_time
      #   select_hour(my_time)
      #
      #   # Generates a select field for hours that defaults to the number given
      #   select_hour(13)
      #
      #   # Generates a select field for hours that defaults to the minutes for the time in my_time
      #   # that is named 'stride' rather than 'second'
      #   select_hour(my_time, :field_name =&gt; 'stride')
      #
      #   # Generates a select field for hours with a custom prompt.  Use :prompt =&gt; true for a
      #   # generic prompt.
      #   select_hour(13, :prompt =&gt;'Choose hour')
      #
      def select_hour(datetime, options = {}, html_options = {})
        DateTimeSelector.new(datetime, options, html_options).select_hour
      end

      # Returns a select tag with options for each of the days 1 through 31 with the current day selected.
      # The &lt;tt&gt;date&lt;/tt&gt; can also be substituted for a hour number.
      # Override the field name using the &lt;tt&gt;:field_name&lt;/tt&gt; option, 'day' by default.
      #
      # ==== Examples
      #   my_date = Time.today + 2.days
      #
      #   # Generates a select field for days that defaults to the day for the date in my_date
      #   select_day(my_time)
      #
      #   # Generates a select field for days that defaults to the number given
      #   select_day(5)
      #
      #   # Generates a select field for days that defaults to the day for the date in my_date
      #   # that is named 'due' rather than 'day'
      #   select_day(my_time, :field_name =&gt; 'due')
      #
      #   # Generates a select field for days with a custom prompt.  Use :prompt =&gt; true for a
      #   # generic prompt.
      #   select_day(5, :prompt =&gt; 'Choose day')
      #
      def select_day(date, options = {}, html_options = {})
        DateTimeSelector.new(date, options, html_options).select_day
      end

      # Returns a select tag with options for each of the months January through December with the current month
      # selected. The month names are presented as keys (what's shown to the user) and the month numbers (1-12) are
      # used as values (what's submitted to the server). It's also possible to use month numbers for the presentation
      # instead of names -- set the &lt;tt&gt;:use_month_numbers&lt;/tt&gt; key in +options+ to true for this to happen. If you
      # want both numbers and names, set the &lt;tt&gt;:add_month_numbers&lt;/tt&gt; key in +options+ to true. If you would prefer
      # to show month names as abbreviations, set the &lt;tt&gt;:use_short_month&lt;/tt&gt; key in +options+ to true. If you want
      # to use your own month names, set the &lt;tt&gt;:use_month_names&lt;/tt&gt; key in +options+ to an array of 12 month names.
      # Override the field name using the &lt;tt&gt;:field_name&lt;/tt&gt; option, 'month' by default.
      #
      # ==== Examples
      #   # Generates a select field for months that defaults to the current month that
      #   # will use keys like &quot;January&quot;, &quot;March&quot;.
      #   select_month(Date.today)
      #
      #   # Generates a select field for months that defaults to the current month that
      #   # is named &quot;start&quot; rather than &quot;month&quot;
      #   select_month(Date.today, :field_name =&gt; 'start')
      #
      #   # Generates a select field for months that defaults to the current month that
      #   # will use keys like &quot;1&quot;, &quot;3&quot;.
      #   select_month(Date.today, :use_month_numbers =&gt; true)
      #
      #   # Generates a select field for months that defaults to the current month that
      #   # will use keys like &quot;1 - January&quot;, &quot;3 - March&quot;.
      #   select_month(Date.today, :add_month_numbers =&gt; true)
      #
      #   # Generates a select field for months that defaults to the current month that
      #   # will use keys like &quot;Jan&quot;, &quot;Mar&quot;.
      #   select_month(Date.today, :use_short_month =&gt; true)
      #
      #   # Generates a select field for months that defaults to the current month that
      #   # will use keys like &quot;Januar&quot;, &quot;Marts.&quot;
      #   select_month(Date.today, :use_month_names =&gt; %w(Januar Februar Marts ...))
      #
      #   # Generates a select field for months with a custom prompt.  Use :prompt =&gt; true for a
      #   # generic prompt.
      #   select_month(14, :prompt =&gt; 'Choose month')
      #
      def select_month(date, options = {}, html_options = {})
        DateTimeSelector.new(date, options, html_options).select_month
      end

      # Returns a select tag with options for each of the five years on each side of the current, which is selected.
      # The five year radius can be changed using the &lt;tt&gt;:start_year&lt;/tt&gt; and &lt;tt&gt;:end_year&lt;/tt&gt; keys in the
      # +options+. Both ascending and descending year lists are supported by making &lt;tt&gt;:start_year&lt;/tt&gt; less than or
      # greater than &lt;tt&gt;:end_year&lt;/tt&gt;. The &lt;tt&gt;date&lt;/tt&gt; can also be substituted for a year given as a number.
      # Override the field name using the &lt;tt&gt;:field_name&lt;/tt&gt; option, 'year' by default.
      #
      # ==== Examples
      #   # Generates a select field for years that defaults to the current year that
      #   # has ascending year values
      #   select_year(Date.today, :start_year =&gt; 1992, :end_year =&gt; 2007)
      #
      #   # Generates a select field for years that defaults to the current year that
      #   # is named 'birth' rather than 'year'
      #   select_year(Date.today, :field_name =&gt; 'birth')
      #
      #   # Generates a select field for years that defaults to the current year that
      #   # has descending year values
      #   select_year(Date.today, :start_year =&gt; 2005, :end_year =&gt; 1900)
      #
      #   # Generates a select field for years that defaults to the year 2006 that
      #   # has ascending year values
      #   select_year(2006, :start_year =&gt; 2000, :end_year =&gt; 2010)
      #
      #   # Generates a select field for years with a custom prompt.  Use :prompt =&gt; true for a
      #   # generic prompt.
      #   select_year(14, :prompt =&gt; 'Choose year')
      #
      def select_year(date, options = {}, html_options = {})
        DateTimeSelector.new(date, options, html_options).select_year
      end
    end

    class DateTimeSelector #:nodoc:
      extend ActiveSupport::Memoizable
      include ActionView::Helpers::TagHelper

      DEFAULT_PREFIX = 'date'.freeze unless const_defined?('DEFAULT_PREFIX')
      POSITION = {
        :year =&gt; 1, :month =&gt; 2, :day =&gt; 3, :hour =&gt; 4, :minute =&gt; 5, :second =&gt; 6
      }.freeze unless const_defined?('POSITION')

      def initialize(datetime, options = {}, html_options = {})
        @options      = options.dup
        @html_options = html_options.dup
        @datetime     = datetime
      end

      def select_datetime
        # TODO: Remove tag conditional
        # Ideally we could just join select_date and select_date for the tag case
        if @options[:tag] &amp;&amp; @options[:ignore_date]
          select_time
        elsif @options[:tag]
          order = date_order.dup
          order -= [:hour, :minute, :second]

          @options[:discard_year]   ||= true unless order.include?(:year)
          @options[:discard_month]  ||= true unless order.include?(:month)
          @options[:discard_day]    ||= true if @options[:discard_month] || !order.include?(:day)
          @options[:discard_minute] ||= true if @options[:discard_hour]
          @options[:discard_second] ||= true unless @options[:include_seconds] &amp;&amp; !@options[:discard_minute]

          # If the day is hidden and the month is visible, the day should be set to the 1st so all month choices are
          # valid (otherwise it could be 31 and february wouldn't be a valid date)
          if @datetime &amp;&amp; @options[:discard_day] &amp;&amp; !@options[:discard_month]
            @datetime = @datetime.change(:day =&gt; 1)
          end

          [:day, :month, :year].each { |o| order.unshift(o) unless order.include?(o) }
          order += [:hour, :minute, :second] unless @options[:discard_hour]

          build_selects_from_types(order)
        else
          &quot;#{select_date}#{@options[:datetime_separator]}#{select_time}&quot;
        end
      end

      def select_date
        order = date_order.dup

        # TODO: Remove tag conditional
        if @options[:tag]
          @options[:discard_hour]     = true
          @options[:discard_minute]   = true
          @options[:discard_second]   = true

          @options[:discard_year]   ||= true unless order.include?(:year)
          @options[:discard_month]  ||= true unless order.include?(:month)
          @options[:discard_day]    ||= true if @options[:discard_month] || !order.include?(:day)

          # If the day is hidden and the month is visible, the day should be set to the 1st so all month choices are
          # valid (otherwise it could be 31 and february wouldn't be a valid date)
          if @datetime &amp;&amp; @options[:discard_day] &amp;&amp; !@options[:discard_month]
            @datetime = @datetime.change(:day =&gt; 1)
          end
        end

        [:day, :month, :year].each { |o| order.unshift(o) unless order.include?(o) }

        build_selects_from_types(order)
      end

      def select_time
        order = []

        # TODO: Remove tag conditional
        if @options[:tag]
          @options[:discard_month]    = true
          @options[:discard_year]     = true
          @options[:discard_day]      = true
          @options[:discard_second] ||= true unless @options[:include_seconds]

          order += [:year, :month, :day] unless @options[:ignore_date]
        end

        order += [:hour, :minute]
        order &lt;&lt; :second if @options[:include_seconds]

        build_selects_from_types(order)
      end

      def select_second
        if @options[:use_hidden] || @options[:discard_second]
          build_hidden(:second, sec) if @options[:include_seconds]
        else
          build_options_and_select(:second, sec)
        end
      end

      def select_minute
        if @options[:use_hidden] || @options[:discard_minute]
          build_hidden(:minute, min)
        else
          build_options_and_select(:minute, min, :step =&gt; @options[:minute_step])
        end
      end

      def select_hour
        if @options[:use_hidden] || @options[:discard_hour]
          build_hidden(:hour, hour)
        else
          build_options_and_select(:hour, hour, :end =&gt; 23)
        end
      end

      def select_day
        if @options[:use_hidden] || @options[:discard_day]
          build_hidden(:day, day)
        else
          build_options_and_select(:day, day, :start =&gt; 1, :end =&gt; 31, :leading_zeros =&gt; false)
        end
      end

      def select_month
        if @options[:use_hidden] || @options[:discard_month]
          build_hidden(:month, month)
        else
          month_options = []
          1.upto(12) do |month_number|
            options = { :value =&gt; month_number }
            options[:selected] = &quot;selected&quot; if month == month_number
            month_options &lt;&lt; content_tag(:option, month_name(month_number), options) + &quot;\n&quot;
          end
          build_select(:month, month_options.join)
        end
      end

      def select_year
        if !@datetime || @datetime == 0
          val = ''
          middle_year = Date.today.year
        else
          val = middle_year = year
        end

        if @options[:use_hidden] || @options[:discard_year]
          build_hidden(:year, val)
        else
          options                 = {}
          options[:start]         = @options[:start_year] || middle_year - 5
          options[:end]           = @options[:end_year] || middle_year + 5
          options[:step]          = options[:start] &lt; options[:end] ? 1 : -1
          options[:leading_zeros] = false

          build_options_and_select(:year, val, options)
        end
      end

      private
        %w( sec min hour day month year ).each do |method|
          define_method(method) do
            @datetime.kind_of?(Fixnum) ? @datetime : @datetime.send(method) if @datetime
          end
        end

        # Returns translated month names, but also ensures that a custom month
        # name array has a leading nil element
        def month_names
          month_names = @options[:use_month_names] || translated_month_names
          month_names.unshift(nil) if month_names.size &lt; 13
          month_names
        end
        memoize :month_names

        # Returns translated month names
        #  =&gt; [nil, &quot;January&quot;, &quot;February&quot;, &quot;March&quot;,
        #           &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
        #           &quot;August&quot;, &quot;September&quot;, &quot;October&quot;,
        #           &quot;November&quot;, &quot;December&quot;]
        #
        # If :use_short_month option is set
        #  =&gt; [nil, &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,
        #           &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]
        def translated_month_names
          begin
            key = @options[:use_short_month] ? :'date.abbr_month_names' : :'date.month_names'
            I18n.translate(key, :locale =&gt; @options[:locale])
          end
        end

        # Lookup month name for number
        #  month_name(1) =&gt; &quot;January&quot;
        #
        # If :use_month_numbers option is passed
        #  month_name(1) =&gt; 1
        #
        # If :add_month_numbers option is passed
        #  month_name(1) =&gt; &quot;1 - January&quot;
        def month_name(number)
          if @options[:use_month_numbers]
            number
          elsif @options[:add_month_numbers]
            &quot;#{number} - #{month_names[number]}&quot;
          else
            month_names[number]
          end
        end

        def date_order
          @options[:order] || translated_date_order
        end
        memoize :date_order

        def translated_date_order
          begin
            I18n.translate(:'date.order', :locale =&gt; @options[:locale]) || []
          end
        end

        # Build full select tag from date type and options
        def build_options_and_select(type, selected, options = {})
          build_select(type, build_options(selected, options))
        end

        # Build select option html from date value and options
        #  build_options(15, :start =&gt; 1, :end =&gt; 31)
        #  =&gt; &quot;&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
        #      &lt;option value=\&quot;2\&quot;&gt;2&lt;/option&gt;
        #      &lt;option value=\&quot;3\&quot;&gt;3&lt;/option&gt;...&quot;
        def build_options(selected, options = {})
          start         = options.delete(:start) || 0
          stop          = options.delete(:end) || 59
          step          = options.delete(:step) || 1
          leading_zeros = options.delete(:leading_zeros).nil? ? true : false

          select_options = []
          start.step(stop, step) do |i|
            value = leading_zeros ? sprintf(&quot;%02d&quot;, i) : i
            tag_options = { :value =&gt; value }
            tag_options[:selected] = &quot;selected&quot; if selected == i
            select_options &lt;&lt; content_tag(:option, value, tag_options)
          end
          select_options.join(&quot;\n&quot;) + &quot;\n&quot;
        end

        # Builds select tag from date type and html select options
        #  build_select(:month, &quot;&lt;option value=&quot;1&quot;&gt;January&lt;/option&gt;...&quot;)
        #  =&gt; &quot;&lt;select id=&quot;post_written_on_2i&quot; name=&quot;post[written_on(2i)]&quot;&gt;
        #        &lt;option value=&quot;1&quot;&gt;January&lt;/option&gt;...
        #      &lt;/select&gt;&quot;
        def build_select(type, select_options_as_html)
          select_options = {
            :id =&gt; input_id_from_type(type),
            :name =&gt; input_name_from_type(type)
          }.merge(@html_options)
          select_options.merge!(:disabled =&gt; 'disabled') if @options[:disabled]

          select_html = &quot;\n&quot;
          select_html &lt;&lt; content_tag(:option, '', :value =&gt; '') + &quot;\n&quot; if @options[:include_blank]
          select_html &lt;&lt; prompt_option_tag(type, @options[:prompt]) + &quot;\n&quot; if @options[:prompt]
          select_html &lt;&lt; select_options_as_html.to_s

          content_tag(:select, select_html, select_options) + &quot;\n&quot;
        end

        # Builds a prompt option tag with supplied options or from default options
        #  prompt_option_tag(:month, :prompt =&gt; 'Select month')
        #  =&gt; &quot;&lt;option value=&quot;&quot;&gt;Select month&lt;/option&gt;&quot;
        def prompt_option_tag(type, options)
          default_options = {:year =&gt; false, :month =&gt; false, :day =&gt; false, :hour =&gt; false, :minute =&gt; false, :second =&gt; false}

          case options
          when Hash
            prompt = default_options.merge(options)[type.to_sym]
          when String
            prompt = options
          else
            prompt = I18n.translate(('datetime.prompts.' + type.to_s).to_sym, :locale =&gt; @options[:locale])
          end

          prompt ? content_tag(:option, prompt, :value =&gt; '') : ''
        end

        # Builds hidden input tag for date part and value
        #  build_hidden(:year, 2008)
        #  =&gt; &quot;&lt;input id=&quot;post_written_on_1i&quot; name=&quot;post[written_on(1i)]&quot; type=&quot;hidden&quot; value=&quot;2008&quot; /&gt;&quot;
        def build_hidden(type, value)
          tag(:input, {
            :type =&gt; &quot;hidden&quot;,
            :id =&gt; input_id_from_type(type),
            :name =&gt; input_name_from_type(type),
            :value =&gt; value
          }) + &quot;\n&quot;
        end

        # Returns the name attribute for the input tag
        #  =&gt; post[written_on(1i)]
        def input_name_from_type(type)
          prefix = @options[:prefix] || ActionView::Helpers::DateTimeSelector::DEFAULT_PREFIX
          prefix += &quot;[#{@options[:index]}]&quot; if @options.has_key?(:index)

          field_name = @options[:field_name] || type
          if @options[:include_position]
            field_name += &quot;(#{ActionView::Helpers::DateTimeSelector::POSITION[type]}i)&quot;
          end

          @options[:discard_type] ? prefix : &quot;#{prefix}[#{field_name}]&quot;
        end

        # Returns the id attribute for the input tag
        #  =&gt; &quot;post_written_on_1i&quot;
        def input_id_from_type(type)
          input_name_from_type(type).gsub(/([\[\(])|(\]\[)/, '_').gsub(/[\]\)]/, '')
        end

        # Given an ordering of datetime components, create the selection html
        # and join them with their appropriate seperators
        def build_selects_from_types(order)
          select = ''
          order.reverse.each do |type|
            separator = separator(type) unless type == order.first # don't add on last field
            select.insert(0, separator.to_s + send(&quot;select_#{type}&quot;).to_s)
          end
          select
        end

        # Returns the separator for a given datetime component
        def separator(type)
          case type
            when :month, :day
              @options[:date_separator]
            when :hour
              (@options[:discard_year] &amp;&amp; @options[:discard_day]) ? &quot;&quot; : @options[:datetime_separator]
            when :minute
              @options[:time_separator]
            when :second
              @options[:include_seconds] ? @options[:time_separator] : &quot;&quot;
          end
        end
    end

    class InstanceTag #:nodoc:
      def to_date_select_tag(options = {}, html_options = {})
        datetime_selector(options, html_options).select_date
      end

      def to_time_select_tag(options = {}, html_options = {})
        datetime_selector(options, html_options).select_time
      end

      def to_datetime_select_tag(options = {}, html_options = {})
        datetime_selector(options, html_options).select_datetime
      end

      private
        def datetime_selector(options, html_options)
          datetime = value(object) || default_datetime(options)

          options = options.dup
          options[:field_name]           = @method_name
          options[:include_position]     = true
          options[:prefix]             ||= @object_name
          options[:index]                = @auto_index if @auto_index &amp;&amp; !options.has_key?(:index)
          options[:datetime_separator] ||= ' &amp;mdash; '
          options[:time_separator]     ||= ' : '

          DateTimeSelector.new(datetime, options.merge(:tag =&gt; true), html_options)
        end

        def default_datetime(options)
          return if options[:include_blank] || options[:prompt]

          case options[:default]
            when nil
              Time.current
            when Date, Time
              options[:default]
            else
              default = options[:default].dup

              # Rename :minute and :second to :min and :sec
              default[:min] ||= default[:minute]
              default[:sec] ||= default[:second]

              time = Time.current

              [:year, :month, :day, :hour, :min, :sec].each do |key|
                default[key] ||= time.send(key)
              end

              Time.utc_time(
                default[:year], default[:month], default[:day],
                default[:hour], default[:min], default[:sec]
              )
          end
        end
    end

    class FormBuilder
      def date_select(method, options = {}, html_options = {})
        @template.date_select(@object_name, method, objectify_options(options), html_options)
      end

      def time_select(method, options = {}, html_options = {})
        @template.time_select(@object_name, method, objectify_options(options), html_options)
      end

      def datetime_select(method, options = {}, html_options = {})
        @template.datetime_select(@object_name, method, objectify_options(options), html_options)
      end
    end
  end
end
</pre>
    </div>
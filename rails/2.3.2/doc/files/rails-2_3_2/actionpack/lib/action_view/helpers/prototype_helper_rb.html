  <div id="fileHeader">
    <h1>prototype_helper.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>rails-2.3.2/actionpack/lib/action_view/helpers/prototype_helper.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Mar 15 23:31:34 -0500 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'set'
require 'active_support/json'

module ActionView
  module Helpers
    # Prototype[http://www.prototypejs.org/] is a JavaScript library that provides
    # DOM[http://en.wikipedia.org/wiki/Document_Object_Model] manipulation,
    # Ajax[http://www.adaptivepath.com/publications/essays/archives/000385.php]
    # functionality, and more traditional object-oriented facilities for JavaScript.
    # This module provides a set of helpers to make it more convenient to call
    # functions from Prototype using Rails, including functionality to call remote
    # Rails methods (that is, making a background request to a Rails action) using Ajax.
    # This means that you can call actions in your controllers without
    # reloading the page, but still update certain parts of it using
    # injections into the DOM. A common use case is having a form that adds
    # a new element to a list without reloading the page or updating a shopping
    # cart total when a new item is added.
    #
    # == Usage
    # To be able to use these helpers, you must first include the Prototype
    # JavaScript framework in your pages.
    #
    #  javascript_include_tag 'prototype'
    #
    # (See the documentation for
    # ActionView::Helpers::JavaScriptHelper for more information on including
    # this and other JavaScript files in your Rails templates.)
    #
    # Now you're ready to call a remote action either through a link...
    #
    #  link_to_remote &quot;Add to cart&quot;,
    #    :url =&gt; { :action =&gt; &quot;add&quot;, :id =&gt; product.id },
    #    :update =&gt; { :success =&gt; &quot;cart&quot;, :failure =&gt; &quot;error&quot; }
    #
    # ...through a form...
    #
    #  &lt;% form_remote_tag :url =&gt; '/shipping' do -%&gt;
    #    &lt;div&gt;&lt;%= submit_tag 'Recalculate Shipping' %&gt;&lt;/div&gt;
    #  &lt;% end -%&gt;
    #
    # ...periodically...
    #
    #  periodically_call_remote(:url =&gt; 'update', :frequency =&gt; '5', :update =&gt; 'ticker')
    #
    # ...or through an observer (i.e., a form or field that is observed and calls a remote
    # action when changed).
    #
    #  &lt;%= observe_field(:searchbox,
    #       :url =&gt; { :action =&gt; :live_search }),
    #       :frequency =&gt; 0.5,
    #       :update =&gt; :hits,
    #       :with =&gt; 'query'
    #       %&gt;
    #
    # As you can see, there are numerous ways to use Prototype's Ajax functions (and actually more than
    # are listed here); check out the documentation for each method to find out more about its usage and options.
    #
    # === Common Options
    # See link_to_remote for documentation of options common to all Ajax
    # helpers; any of the options specified by link_to_remote can be used
    # by the other helpers.
    #
    # == Designing your Rails actions for Ajax
    # When building your action handlers (that is, the Rails actions that receive your background requests), it's
    # important to remember a few things.  First, whatever your action would normally return to the browser, it will
    # return to the Ajax call.  As such, you typically don't want to render with a layout.  This call will cause
    # the layout to be transmitted back to your page, and, if you have a full HTML/CSS, will likely mess a lot of things up.
    # You can turn the layout off on particular actions by doing the following:
    #
    #  class SiteController &lt; ActionController::Base
    #    layout &quot;standard&quot;, :except =&gt; [:ajax_method, :more_ajax, :another_ajax]
    #  end
    #
    # Optionally, you could do this in the method you wish to lack a layout:
    #
    #  render :layout =&gt; false
    #
    # You can tell the type of request from within your action using the &lt;tt&gt;request.xhr?&lt;/tt&gt; (XmlHttpRequest, the
    # method that Ajax uses to make background requests) method.
    #  def name
    #    # Is this an XmlHttpRequest request?
    #    if (request.xhr?)
    #      render :text =&gt; @name.to_s
    #    else
    #      # No?  Then render an action.
    #      render :action =&gt; 'view_attribute', :attr =&gt; @name
    #    end
    #  end
    #
    # The else clause can be left off and the current action will render with full layout and template. An extension
    # to this solution was posted to Ryan Heneise's blog at ArtOfMission[&quot;http://www.artofmission.com/&quot;].
    #
    #  layout proc{ |c| c.request.xhr? ? false : &quot;application&quot; }
    #
    # Dropping this in your ApplicationController turns the layout off for every request that is an &quot;xhr&quot; request.
    #
    # If you are just returning a little data or don't want to build a template for your output, you may opt to simply
    # render text output, like this:
    #
    #  render :text =&gt; 'Return this from my method!'
    #
    # Since whatever the method returns is injected into the DOM, this will simply inject some text (or HTML, if you
    # tell it to).  This is usually how small updates, such updating a cart total or a file count, are handled.
    #
    # == Updating multiple elements
    # See JavaScriptGenerator for information on updating multiple elements
    # on the page in an Ajax response.
    module PrototypeHelper
      unless const_defined? :CALLBACKS
        CALLBACKS    = Set.new([ :create, :uninitialized, :loading, :loaded,
                         :interactive, :complete, :failure, :success ] +
                         (100..599).to_a)
        AJAX_OPTIONS = Set.new([ :before, :after, :condition, :url,
                         :asynchronous, :method, :insertion, :position,
                         :form, :with, :update, :script, :type ]).merge(CALLBACKS)
      end

      # Returns a link to a remote action defined by &lt;tt&gt;options[:url]&lt;/tt&gt;
      # (using the url_for format) that's called in the background using
      # XMLHttpRequest. The result of that request can then be inserted into a
      # DOM object whose id can be specified with &lt;tt&gt;options[:update]&lt;/tt&gt;.
      # Usually, the result would be a partial prepared by the controller with
      # render :partial.
      #
      # Examples:
      #   # Generates: &lt;a href=&quot;#&quot; onclick=&quot;new Ajax.Updater('posts', '/blog/destroy/3', {asynchronous:true, evalScripts:true});
      #   #            return false;&quot;&gt;Delete this post&lt;/a&gt;
      #   link_to_remote &quot;Delete this post&quot;, :update =&gt; &quot;posts&quot;,
      #     :url =&gt; { :action =&gt; &quot;destroy&quot;, :id =&gt; post.id }
      #
      #   # Generates: &lt;a href=&quot;#&quot; onclick=&quot;new Ajax.Updater('emails', '/mail/list_emails', {asynchronous:true, evalScripts:true});
      #   #            return false;&quot;&gt;&lt;img alt=&quot;Refresh&quot; src=&quot;/images/refresh.png?&quot; /&gt;&lt;/a&gt;
      #   link_to_remote(image_tag(&quot;refresh&quot;), :update =&gt; &quot;emails&quot;,
      #     :url =&gt; { :action =&gt; &quot;list_emails&quot; })
      #
      # You can override the generated HTML options by specifying a hash in
      # &lt;tt&gt;options[:html]&lt;/tt&gt;.
      #
      #   link_to_remote &quot;Delete this post&quot;, :update =&gt; &quot;posts&quot;,
      #     :url  =&gt; post_url(@post), :method =&gt; :delete,
      #     :html =&gt; { :class  =&gt; &quot;destructive&quot; }
      #
      # You can also specify a hash for &lt;tt&gt;options[:update]&lt;/tt&gt; to allow for
      # easy redirection of output to an other DOM element if a server-side
      # error occurs:
      #
      # Example:
      #   # Generates: &lt;a href=&quot;#&quot; onclick=&quot;new Ajax.Updater({success:'posts',failure:'error'}, '/blog/destroy/5',
      #   #            {asynchronous:true, evalScripts:true}); return false;&quot;&gt;Delete this post&lt;/a&gt;
      #   link_to_remote &quot;Delete this post&quot;,
      #     :url =&gt; { :action =&gt; &quot;destroy&quot;, :id =&gt; post.id },
      #     :update =&gt; { :success =&gt; &quot;posts&quot;, :failure =&gt; &quot;error&quot; }
      #
      # Optionally, you can use the &lt;tt&gt;options[:position]&lt;/tt&gt; parameter to
      # influence how the target DOM element is updated. It must be one of
      # &lt;tt&gt;:before&lt;/tt&gt;, &lt;tt&gt;:top&lt;/tt&gt;, &lt;tt&gt;:bottom&lt;/tt&gt;, or &lt;tt&gt;:after&lt;/tt&gt;.
      #
      # The method used is by default POST. You can also specify GET or you
      # can simulate PUT or DELETE over POST. All specified with &lt;tt&gt;options[:method]&lt;/tt&gt;
      #
      # Example:
      #   # Generates: &lt;a href=&quot;#&quot; onclick=&quot;new Ajax.Request('/person/4', {asynchronous:true, evalScripts:true, method:'delete'});
      #   #            return false;&quot;&gt;Destroy&lt;/a&gt;
      #   link_to_remote &quot;Destroy&quot;, :url =&gt; person_url(:id =&gt; person), :method =&gt; :delete
      #
      # By default, these remote requests are processed asynchronous during
      # which various JavaScript callbacks can be triggered (for progress
      # indicators and the likes). All callbacks get access to the
      # &lt;tt&gt;request&lt;/tt&gt; object, which holds the underlying XMLHttpRequest.
      #
      # To access the server response, use &lt;tt&gt;request.responseText&lt;/tt&gt;, to
      # find out the HTTP status, use &lt;tt&gt;request.status&lt;/tt&gt;.
      #
      # Example:
      #   # Generates: &lt;a href=&quot;#&quot; onclick=&quot;new Ajax.Request('/words/undo?n=33', {asynchronous:true, evalScripts:true,
      #   #            onComplete:function(request){undoRequestCompleted(request)}}); return false;&quot;&gt;hello&lt;/a&gt;
      #   word = 'hello'
      #   link_to_remote word,
      #     :url =&gt; { :action =&gt; &quot;undo&quot;, :n =&gt; word_counter },
      #     :complete =&gt; &quot;undoRequestCompleted(request)&quot;
      #
      # The callbacks that may be specified are (in order):
      #
      # &lt;tt&gt;:loading&lt;/tt&gt;::       Called when the remote document is being
      #                           loaded with data by the browser.
      # &lt;tt&gt;:loaded&lt;/tt&gt;::        Called when the browser has finished loading
      #                           the remote document.
      # &lt;tt&gt;:interactive&lt;/tt&gt;::   Called when the user can interact with the
      #                           remote document, even though it has not
      #                           finished loading.
      # &lt;tt&gt;:success&lt;/tt&gt;::       Called when the XMLHttpRequest is completed,
      #                           and the HTTP status code is in the 2XX range.
      # &lt;tt&gt;:failure&lt;/tt&gt;::       Called when the XMLHttpRequest is completed,
      #                           and the HTTP status code is not in the 2XX
      #                           range.
      # &lt;tt&gt;:complete&lt;/tt&gt;::      Called when the XMLHttpRequest is complete
      #                           (fires after success/failure if they are
      #                           present).
      #
      # You can further refine &lt;tt&gt;:success&lt;/tt&gt; and &lt;tt&gt;:failure&lt;/tt&gt; by
      # adding additional callbacks for specific status codes.
      #
      # Example:
      #   # Generates: &lt;a href=&quot;#&quot; onclick=&quot;new Ajax.Request('/testing/action', {asynchronous:true, evalScripts:true,
      #   #            on404:function(request){alert('Not found...? Wrong URL...?')},
      #   #            onFailure:function(request){alert('HTTP Error ' + request.status + '!')}}); return false;&quot;&gt;hello&lt;/a&gt;
      #   link_to_remote word,
      #     :url =&gt; { :action =&gt; &quot;action&quot; },
      #     404 =&gt; &quot;alert('Not found...? Wrong URL...?')&quot;,
      #     :failure =&gt; &quot;alert('HTTP Error ' + request.status + '!')&quot;
      #
      # A status code callback overrides the success/failure handlers if
      # present.
      #
      # If you for some reason or another need synchronous processing (that'll
      # block the browser while the request is happening), you can specify
      # &lt;tt&gt;options[:type] = :synchronous&lt;/tt&gt;.
      #
      # You can customize further browser side call logic by passing in
      # JavaScript code snippets via some optional parameters. In their order
      # of use these are:
      #
      # &lt;tt&gt;:confirm&lt;/tt&gt;::      Adds confirmation dialog.
      # &lt;tt&gt;:condition&lt;/tt&gt;::    Perform remote request conditionally
      #                          by this expression. Use this to
      #                          describe browser-side conditions when
      #                          request should not be initiated.
      # &lt;tt&gt;:before&lt;/tt&gt;::       Called before request is initiated.
      # &lt;tt&gt;:after&lt;/tt&gt;::        Called immediately after request was
      #                          initiated and before &lt;tt&gt;:loading&lt;/tt&gt;.
      # &lt;tt&gt;:submit&lt;/tt&gt;::       Specifies the DOM element ID that's used
      #                          as the parent of the form elements. By
      #                          default this is the current form, but
      #                          it could just as well be the ID of a
      #                          table row or any other DOM element.
      # &lt;tt&gt;:with&lt;/tt&gt;::         A JavaScript expression specifying
      #                          the parameters for the XMLHttpRequest.
      #                          Any expressions should return a valid
      #                          URL query string.
      #
      #                          Example:
      #
      #                            :with =&gt; &quot;'name=' + $('name').value&quot;
      #
      # You can generate a link that uses AJAX in the general case, while
      # degrading gracefully to plain link behavior in the absence of
      # JavaScript by setting &lt;tt&gt;html_options[:href]&lt;/tt&gt; to an alternate URL.
      # Note the extra curly braces around the &lt;tt&gt;options&lt;/tt&gt; hash separate
      # it as the second parameter from &lt;tt&gt;html_options&lt;/tt&gt;, the third.
      #
      # Example:
      #   link_to_remote &quot;Delete this post&quot;,
      #     { :update =&gt; &quot;posts&quot;, :url =&gt; { :action =&gt; &quot;destroy&quot;, :id =&gt; post.id } },
      #     :href =&gt; url_for(:action =&gt; &quot;destroy&quot;, :id =&gt; post.id)
      def link_to_remote(name, options = {}, html_options = nil)
        link_to_function(name, remote_function(options), html_options || options.delete(:html))
      end

      # Creates a button with an onclick event which calls a remote action
      # via XMLHttpRequest
      # The options for specifying the target with :url
      # and defining callbacks is the same as link_to_remote.
      def button_to_remote(name, options = {}, html_options = {})
        button_to_function(name, remote_function(options), html_options)
      end

      # Periodically calls the specified url (&lt;tt&gt;options[:url]&lt;/tt&gt;) every
      # &lt;tt&gt;options[:frequency]&lt;/tt&gt; seconds (default is 10). Usually used to
      # update a specified div (&lt;tt&gt;options[:update]&lt;/tt&gt;) with the results
      # of the remote call. The options for specifying the target with &lt;tt&gt;:url&lt;/tt&gt;
      # and defining callbacks is the same as link_to_remote.
      # Examples:
      #  # Call get_averages and put its results in 'avg' every 10 seconds
      #  # Generates:
      #  #      new PeriodicalExecuter(function() {new Ajax.Updater('avg', '/grades/get_averages',
      #  #      {asynchronous:true, evalScripts:true})}, 10)
      #  periodically_call_remote(:url =&gt; { :action =&gt; 'get_averages' }, :update =&gt; 'avg')
      #
      #  # Call invoice every 10 seconds with the id of the customer
      #  # If it succeeds, update the invoice DIV; if it fails, update the error DIV
      #  # Generates:
      #  #      new PeriodicalExecuter(function() {new Ajax.Updater({success:'invoice',failure:'error'},
      #  #      '/testing/invoice/16', {asynchronous:true, evalScripts:true})}, 10)
      #  periodically_call_remote(:url =&gt; { :action =&gt; 'invoice', :id =&gt; customer.id },
      #     :update =&gt; { :success =&gt; &quot;invoice&quot;, :failure =&gt; &quot;error&quot; }
      #
      #  # Call update every 20 seconds and update the new_block DIV
      #  # Generates:
      #  # new PeriodicalExecuter(function() {new Ajax.Updater('news_block', 'update', {asynchronous:true, evalScripts:true})}, 20)
      #  periodically_call_remote(:url =&gt; 'update', :frequency =&gt; '20', :update =&gt; 'news_block')
      #
      def periodically_call_remote(options = {})
         frequency = options[:frequency] || 10 # every ten seconds by default
         code = &quot;new PeriodicalExecuter(function() {#{remote_function(options)}}, #{frequency})&quot;
         javascript_tag(code)
      end

      # Returns a form tag that will submit using XMLHttpRequest in the
      # background instead of the regular reloading POST arrangement. Even
      # though it's using JavaScript to serialize the form elements, the form
      # submission will work just like a regular submission as viewed by the
      # receiving side (all elements available in &lt;tt&gt;params&lt;/tt&gt;). The options for
      # specifying the target with &lt;tt&gt;:url&lt;/tt&gt; and defining callbacks is the same as
      # +link_to_remote+.
      #
      # A &quot;fall-through&quot; target for browsers that doesn't do JavaScript can be
      # specified with the &lt;tt&gt;:action&lt;/tt&gt;/&lt;tt&gt;:method&lt;/tt&gt; options on &lt;tt&gt;:html&lt;/tt&gt;.
      #
      # Example:
      #   # Generates:
      #   #      &lt;form action=&quot;/some/place&quot; method=&quot;post&quot; onsubmit=&quot;new Ajax.Request('',
      #   #      {asynchronous:true, evalScripts:true, parameters:Form.serialize(this)}); return false;&quot;&gt;
      #   form_remote_tag :html =&gt; { :action =&gt;
      #     url_for(:controller =&gt; &quot;some&quot;, :action =&gt; &quot;place&quot;) }
      #
      # The Hash passed to the &lt;tt&gt;:html&lt;/tt&gt; key is equivalent to the options (2nd)
      # argument in the FormTagHelper.form_tag method.
      #
      # By default the fall-through action is the same as the one specified in
      # the &lt;tt&gt;:url&lt;/tt&gt; (and the default method is &lt;tt&gt;:post&lt;/tt&gt;).
      #
      # form_remote_tag also takes a block, like form_tag:
      #   # Generates:
      #   #     &lt;form action=&quot;/&quot; method=&quot;post&quot; onsubmit=&quot;new Ajax.Request('/',
      #   #     {asynchronous:true, evalScripts:true, parameters:Form.serialize(this)});
      #   #     return false;&quot;&gt; &lt;div&gt;&lt;input name=&quot;commit&quot; type=&quot;submit&quot; value=&quot;Save&quot; /&gt;&lt;/div&gt;
      #   #     &lt;/form&gt;
      #   &lt;% form_remote_tag :url =&gt; '/posts' do -%&gt;
      #     &lt;div&gt;&lt;%= submit_tag 'Save' %&gt;&lt;/div&gt;
      #   &lt;% end -%&gt;
      def form_remote_tag(options = {}, &amp;block)
        options[:form] = true

        options[:html] ||= {}
        options[:html][:onsubmit] =
          (options[:html][:onsubmit] ? options[:html][:onsubmit] + &quot;; &quot; : &quot;&quot;) +
          &quot;#{remote_function(options)}; return false;&quot;

        form_tag(options[:html].delete(:action) || url_for(options[:url]), options[:html], &amp;block)
      end

      # Creates a form that will submit using XMLHttpRequest in the background
      # instead of the regular reloading POST arrangement and a scope around a
      # specific resource that is used as a base for questioning about
      # values for the fields.
      #
      # === Resource
      #
      # Example:
      #   &lt;% remote_form_for(@post) do |f| %&gt;
      #     ...
      #   &lt;% end %&gt;
      #
      # This will expand to be the same as:
      #
      #   &lt;% remote_form_for :post, @post, :url =&gt; post_path(@post), :html =&gt; { :method =&gt; :put, :class =&gt; &quot;edit_post&quot;, :id =&gt; &quot;edit_post_45&quot; } do |f| %&gt;
      #     ...
      #   &lt;% end %&gt;
      #
      # === Nested Resource
      #
      # Example:
      #   &lt;% remote_form_for([@post, @comment]) do |f| %&gt;
      #     ...
      #   &lt;% end %&gt;
      #
      # This will expand to be the same as:
      #
      #   &lt;% remote_form_for :comment, @comment, :url =&gt; post_comment_path(@post, @comment), :html =&gt; { :method =&gt; :put, :class =&gt; &quot;edit_comment&quot;, :id =&gt; &quot;edit_comment_45&quot; } do |f| %&gt;
      #     ...
      #   &lt;% end %&gt;
      #
      # If you don't need to attach a form to a resource, then check out form_remote_tag.
      #
      # See FormHelper#form_for for additional semantics.
      def remote_form_for(record_or_name_or_array, *args, &amp;proc)
        options = args.extract_options!

        case record_or_name_or_array
        when String, Symbol
          object_name = record_or_name_or_array
        when Array
          object = record_or_name_or_array.last
          object_name = ActionController::RecordIdentifier.singular_class_name(object)
          apply_form_for_options!(record_or_name_or_array, options)
          args.unshift object
        else
          object      = record_or_name_or_array
          object_name = ActionController::RecordIdentifier.singular_class_name(record_or_name_or_array)
          apply_form_for_options!(object, options)
          args.unshift object
        end

        concat(form_remote_tag(options))
        fields_for(object_name, *(args &lt;&lt; options), &amp;proc)
        concat('&lt;/form&gt;')
      end
      alias_method :form_remote_for, :remote_form_for

      # Returns a button input tag with the element name of +name+ and a value (i.e., display text) of +value+
      # that will submit form using XMLHttpRequest in the background instead of a regular POST request that
      # reloads the page.
      #
      #  # Create a button that submits to the create action
      #  #
      #  # Generates: &lt;input name=&quot;create_btn&quot; onclick=&quot;new Ajax.Request('/testing/create',
      #  #     {asynchronous:true, evalScripts:true, parameters:Form.serialize(this.form)});
      #  #     return false;&quot; type=&quot;button&quot; value=&quot;Create&quot; /&gt;
      #  &lt;%= submit_to_remote 'create_btn', 'Create', :url =&gt; { :action =&gt; 'create' } %&gt;
      #
      #  # Submit to the remote action update and update the DIV succeed or fail based
      #  # on the success or failure of the request
      #  #
      #  # Generates: &lt;input name=&quot;update_btn&quot; onclick=&quot;new Ajax.Updater({success:'succeed',failure:'fail'},
      #  #      '/testing/update', {asynchronous:true, evalScripts:true, parameters:Form.serialize(this.form)});
      #  #      return false;&quot; type=&quot;button&quot; value=&quot;Update&quot; /&gt;
      #  &lt;%= submit_to_remote 'update_btn', 'Update', :url =&gt; { :action =&gt; 'update' },
      #     :update =&gt; { :success =&gt; &quot;succeed&quot;, :failure =&gt; &quot;fail&quot; }
      #
      # &lt;tt&gt;options&lt;/tt&gt; argument is the same as in form_remote_tag.
      def submit_to_remote(name, value, options = {})
        options[:with] ||= 'Form.serialize(this.form)'

        html_options = options.delete(:html) || {}
        html_options[:name] = name

        button_to_remote(value, options, html_options)
      end

      # Returns '&lt;tt&gt;eval(request.responseText)&lt;/tt&gt;' which is the JavaScript function
      # that +form_remote_tag+ can call in &lt;tt&gt;:complete&lt;/tt&gt; to evaluate a multiple
      # update return document using +update_element_function+ calls.
      def evaluate_remote_response
        &quot;eval(request.responseText)&quot;
      end

      # Returns the JavaScript needed for a remote function.
      # Takes the same arguments as link_to_remote.
      #
      # Example:
      #   # Generates: &lt;select id=&quot;options&quot; onchange=&quot;new Ajax.Updater('options',
      #   # '/testing/update_options', {asynchronous:true, evalScripts:true})&quot;&gt;
      #   &lt;select id=&quot;options&quot; onchange=&quot;&lt;%= remote_function(:update =&gt; &quot;options&quot;,
      #       :url =&gt; { :action =&gt; :update_options }) %&gt;&quot;&gt;
      #     &lt;option value=&quot;0&quot;&gt;Hello&lt;/option&gt;
      #     &lt;option value=&quot;1&quot;&gt;World&lt;/option&gt;
      #   &lt;/select&gt;
      def remote_function(options)
        javascript_options = options_for_ajax(options)

        update = ''
        if options[:update] &amp;&amp; options[:update].is_a?(Hash)
          update  = []
          update &lt;&lt; &quot;success:'#{options[:update][:success]}'&quot; if options[:update][:success]
          update &lt;&lt; &quot;failure:'#{options[:update][:failure]}'&quot; if options[:update][:failure]
          update  = '{' + update.join(',') + '}'
        elsif options[:update]
          update &lt;&lt; &quot;'#{options[:update]}'&quot;
        end

        function = update.empty? ?
          &quot;new Ajax.Request(&quot; :
          &quot;new Ajax.Updater(#{update}, &quot;

        url_options = options[:url]
        url_options = url_options.merge(:escape =&gt; false) if url_options.is_a?(Hash)
        function &lt;&lt; &quot;'#{escape_javascript(url_for(url_options))}'&quot;
        function &lt;&lt; &quot;, #{javascript_options})&quot;

        function = &quot;#{options[:before]}; #{function}&quot; if options[:before]
        function = &quot;#{function}; #{options[:after]}&quot;  if options[:after]
        function = &quot;if (#{options[:condition]}) { #{function}; }&quot; if options[:condition]
        function = &quot;if (confirm('#{escape_javascript(options[:confirm])}')) { #{function}; }&quot; if options[:confirm]

        return function
      end

      # Observes the field with the DOM ID specified by +field_id+ and calls a
      # callback when its contents have changed. The default callback is an
      # Ajax call. By default the value of the observed field is sent as a
      # parameter with the Ajax call.
      #
      # Example:
      #  # Generates: new Form.Element.Observer('suggest', 0.25, function(element, value) {new Ajax.Updater('suggest',
      #  #         '/testing/find_suggestion', {asynchronous:true, evalScripts:true, parameters:'q=' + value})})
      #  &lt;%= observe_field :suggest, :url =&gt; { :action =&gt; :find_suggestion },
      #       :frequency =&gt; 0.25,
      #       :update =&gt; :suggest,
      #       :with =&gt; 'q'
      #       %&gt;
      #
      # Required +options+ are either of:
      # &lt;tt&gt;:url&lt;/tt&gt;::       +url_for+-style options for the action to call
      #                       when the field has changed.
      # &lt;tt&gt;:function&lt;/tt&gt;::  Instead of making a remote call to a URL, you
      #                       can specify javascript code to be called instead.
      #                       Note that the value of this option is used as the
      #                       *body* of the javascript function, a function definition
      #                       with parameters named element and value will be generated for you
      #                       for example:
      #                         observe_field(&quot;glass&quot;, :frequency =&gt; 1, :function =&gt; &quot;alert('Element changed')&quot;)
      #                       will generate:
      #                         new Form.Element.Observer('glass', 1, function(element, value) {alert('Element changed')})
      #                       The element parameter is the DOM element being observed, and the value is its value at the
      #                       time the observer is triggered.
      #
      # Additional options are:
      # &lt;tt&gt;:frequency&lt;/tt&gt;:: The frequency (in seconds) at which changes to
      #                       this field will be detected. Not setting this
      #                       option at all or to a value equal to or less than
      #                       zero will use event based observation instead of
      #                       time based observation.
      # &lt;tt&gt;:update&lt;/tt&gt;::    Specifies the DOM ID of the element whose
      #                       innerHTML should be updated with the
      #                       XMLHttpRequest response text.
      # &lt;tt&gt;:with&lt;/tt&gt;::      A JavaScript expression specifying the parameters
      #                       for the XMLHttpRequest. The default is to send the
      #                       key and value of the observed field. Any custom
      #                       expressions should return a valid URL query string.
      #                       The value of the field is stored in the JavaScript
      #                       variable +value+.
      #
      #                       Examples
      #
      #                         :with =&gt; &quot;'my_custom_key=' + value&quot;
      #                         :with =&gt; &quot;'person[name]=' + prompt('New name')&quot;
      #                         :with =&gt; &quot;Form.Element.serialize('other-field')&quot;
      #
      #                       Finally
      #                         :with =&gt; 'name'
      #                       is shorthand for
      #                         :with =&gt; &quot;'name=' + value&quot;
      #                       This essentially just changes the key of the parameter.
      #
      # Additionally, you may specify any of the options documented in the
      # &lt;em&gt;Common options&lt;/em&gt; section at the top of this document.
      #
      # Example:
      #
      #   # Sends params: {:title =&gt; 'Title of the book'} when the book_title input
      #   # field is changed.
      #   observe_field 'book_title',
      #     :url =&gt; 'http://example.com/books/edit/1',
      #     :with =&gt; 'title'
      #
      #
      def observe_field(field_id, options = {})
        if options[:frequency] &amp;&amp; options[:frequency] &gt; 0
          build_observer('Form.Element.Observer', field_id, options)
        else
          build_observer('Form.Element.EventObserver', field_id, options)
        end
      end

      # Observes the form with the DOM ID specified by +form_id+ and calls a
      # callback when its contents have changed. The default callback is an
      # Ajax call. By default all fields of the observed field are sent as
      # parameters with the Ajax call.
      #
      # The +options+ for +observe_form+ are the same as the options for
      # +observe_field+. The JavaScript variable +value+ available to the
      # &lt;tt&gt;:with&lt;/tt&gt; option is set to the serialized form by default.
      def observe_form(form_id, options = {})
        if options[:frequency]
          build_observer('Form.Observer', form_id, options)
        else
          build_observer('Form.EventObserver', form_id, options)
        end
      end

      # All the methods were moved to GeneratorMethods so that
      # #include_helpers_from_context has nothing to overwrite.
      class JavaScriptGenerator #:nodoc:
        def initialize(context, &amp;block) #:nodoc:
          @context, @lines = context, []
          include_helpers_from_context
          @context.with_output_buffer(@lines) do
            @context.instance_exec(self, &amp;block)
          end
        end

        private
          def include_helpers_from_context
            extend @context.helpers if @context.respond_to?(:helpers)
            extend GeneratorMethods
          end

        # JavaScriptGenerator generates blocks of JavaScript code that allow you
        # to change the content and presentation of multiple DOM elements.  Use
        # this in your Ajax response bodies, either in a &lt;script&gt; tag or as plain
        # JavaScript sent with a Content-type of &quot;text/javascript&quot;.
        #
        # Create new instances with PrototypeHelper#update_page or with
        # ActionController::Base#render, then call +insert_html+, +replace_html+,
        # +remove+, +show+, +hide+, +visual_effect+, or any other of the built-in
        # methods on the yielded generator in any order you like to modify the
        # content and appearance of the current page.
        #
        # Example:
        #
        #   # Generates:
        #   #     new Element.insert(&quot;list&quot;, { bottom: &quot;&lt;li&gt;Some item&lt;/li&gt;&quot; });
        #   #     new Effect.Highlight(&quot;list&quot;);
        #   #     [&quot;status-indicator&quot;, &quot;cancel-link&quot;].each(Element.hide);
        #   update_page do |page|
        #     page.insert_html :bottom, 'list', &quot;&lt;li&gt;#{@item.name}&lt;/li&gt;&quot;
        #     page.visual_effect :highlight, 'list'
        #     page.hide 'status-indicator', 'cancel-link'
        #   end
        #
        #
        # Helper methods can be used in conjunction with JavaScriptGenerator.
        # When a helper method is called inside an update block on the +page+
        # object, that method will also have access to a +page+ object.
        #
        # Example:
        #
        #   module ApplicationHelper
        #     def update_time
        #       page.replace_html 'time', Time.now.to_s(:db)
        #       page.visual_effect :highlight, 'time'
        #     end
        #   end
        #
        #   # Controller action
        #   def poll
        #     render(:update) { |page| page.update_time }
        #   end
        #
        # Calls to JavaScriptGenerator not matching a helper method below
        # generate a proxy to the JavaScript Class named by the method called.
        #
        # Examples:
        #
        #   # Generates:
        #   #     Foo.init();
        #   update_page do |page|
        #     page.foo.init
        #   end
        #
        #   # Generates:
        #   #     Event.observe('one', 'click', function () {
        #   #       $('two').show();
        #   #     });
        #   update_page do |page|
        #     page.event.observe('one', 'click') do |p|
        #      p[:two].show
        #     end
        #   end
        #
        # You can also use PrototypeHelper#update_page_tag instead of
        # PrototypeHelper#update_page to wrap the generated JavaScript in a
        # &lt;script&gt; tag.
        module GeneratorMethods
          def to_s #:nodoc:
            returning javascript = @lines * $/ do
              if ActionView::Base.debug_rjs
                source = javascript.dup
                javascript.replace &quot;try {\n#{source}\n} catch (e) &quot;
                javascript &lt;&lt; &quot;{ alert('RJS error:\\n\\n' + e.toString()); alert('#{source.gsub('\\','\0\0').gsub(/\r\n|\n|\r/, &quot;\\n&quot;).gsub(/[&quot;']/) { |m| &quot;\\#{m}&quot; }}'); throw e }&quot;
              end
            end
          end

          # Returns a element reference by finding it through +id+ in the DOM. This element can then be
          # used for further method calls. Examples:
          #
          #   page['blank_slate']                  # =&gt; $('blank_slate');
          #   page['blank_slate'].show             # =&gt; $('blank_slate').show();
          #   page['blank_slate'].show('first').up # =&gt; $('blank_slate').show('first').up();
          #
          # You can also pass in a record, which will use ActionController::RecordIdentifier.dom_id to lookup
          # the correct id:
          #
          #   page[@post]     # =&gt; $('post_45')
          #   page[Post.new]  # =&gt; $('new_post')
          def [](id)
            case id
              when String, Symbol, NilClass
                JavaScriptElementProxy.new(self, id)
              else
                JavaScriptElementProxy.new(self, ActionController::RecordIdentifier.dom_id(id))
            end
          end

          # Returns an object whose &lt;tt&gt;to_json&lt;/tt&gt; evaluates to +code+. Use this to pass a literal JavaScript
          # expression as an argument to another JavaScriptGenerator method.
          def literal(code)
            ActiveSupport::JSON::Variable.new(code.to_s)
          end

          # Returns a collection reference by finding it through a CSS +pattern+ in the DOM. This collection can then be
          # used for further method calls. Examples:
          #
          #   page.select('p')                      # =&gt; $$('p');
          #   page.select('p.welcome b').first      # =&gt; $$('p.welcome b').first();
          #   page.select('p.welcome b').first.hide # =&gt; $$('p.welcome b').first().hide();
          #
          # You can also use prototype enumerations with the collection.  Observe:
          #
          #   # Generates: $$('#items li').each(function(value) { value.hide(); });
          #   page.select('#items li').each do |value|
          #     value.hide
          #   end
          #
          # Though you can call the block param anything you want, they are always rendered in the
          # javascript as 'value, index.'  Other enumerations, like collect() return the last statement:
          #
          #   # Generates: var hidden = $$('#items li').collect(function(value, index) { return value.hide(); });
          #   page.select('#items li').collect('hidden') do |item|
          #     item.hide
          #   end
          #
          def select(pattern)
            JavaScriptElementCollectionProxy.new(self, pattern)
          end

          # Inserts HTML at the specified +position+ relative to the DOM element
          # identified by the given +id+.
          #
          # +position+ may be one of:
          #
          # &lt;tt&gt;:top&lt;/tt&gt;::    HTML is inserted inside the element, before the
          #                    element's existing content.
          # &lt;tt&gt;:bottom&lt;/tt&gt;:: HTML is inserted inside the element, after the
          #                    element's existing content.
          # &lt;tt&gt;:before&lt;/tt&gt;:: HTML is inserted immediately preceding the element.
          # &lt;tt&gt;:after&lt;/tt&gt;::  HTML is inserted immediately following the element.
          #
          # +options_for_render+ may be either a string of HTML to insert, or a hash
          # of options to be passed to ActionView::Base#render.  For example:
          #
          #   # Insert the rendered 'navigation' partial just before the DOM
          #   # element with ID 'content'.
          #   # Generates: Element.insert(&quot;content&quot;, { before: &quot;-- Contents of 'navigation' partial --&quot; });
          #   page.insert_html :before, 'content', :partial =&gt; 'navigation'
          #
          #   # Add a list item to the bottom of the &lt;ul&gt; with ID 'list'.
          #   # Generates: Element.insert(&quot;list&quot;, { bottom: &quot;&lt;li&gt;Last item&lt;/li&gt;&quot; });
          #   page.insert_html :bottom, 'list', '&lt;li&gt;Last item&lt;/li&gt;'
          #
          def insert_html(position, id, *options_for_render)
            content = javascript_object_for(render(*options_for_render))
            record &quot;Element.insert(\&quot;#{id}\&quot;, { #{position.to_s.downcase}: #{content} });&quot;
          end

          # Replaces the inner HTML of the DOM element with the given +id+.
          #
          # +options_for_render+ may be either a string of HTML to insert, or a hash
          # of options to be passed to ActionView::Base#render.  For example:
          #
          #   # Replace the HTML of the DOM element having ID 'person-45' with the
          #   # 'person' partial for the appropriate object.
          #   # Generates:  Element.update(&quot;person-45&quot;, &quot;-- Contents of 'person' partial --&quot;);
          #   page.replace_html 'person-45', :partial =&gt; 'person', :object =&gt; @person
          #
          def replace_html(id, *options_for_render)
            call 'Element.update', id, render(*options_for_render)
          end

          # Replaces the &quot;outer HTML&quot; (i.e., the entire element, not just its
          # contents) of the DOM element with the given +id+.
          #
          # +options_for_render+ may be either a string of HTML to insert, or a hash
          # of options to be passed to ActionView::Base#render.  For example:
          #
          #   # Replace the DOM element having ID 'person-45' with the
          #   # 'person' partial for the appropriate object.
          #   page.replace 'person-45', :partial =&gt; 'person', :object =&gt; @person
          #
          # This allows the same partial that is used for the +insert_html+ to
          # be also used for the input to +replace+ without resorting to
          # the use of wrapper elements.
          #
          # Examples:
          #
          #   &lt;div id=&quot;people&quot;&gt;
          #     &lt;%= render :partial =&gt; 'person', :collection =&gt; @people %&gt;
          #   &lt;/div&gt;
          #
          #   # Insert a new person
          #   #
          #   # Generates: new Insertion.Bottom({object: &quot;Matz&quot;, partial: &quot;person&quot;}, &quot;&quot;);
          #   page.insert_html :bottom, :partial =&gt; 'person', :object =&gt; @person
          #
          #   # Replace an existing person
          #
          #   # Generates: Element.replace(&quot;person_45&quot;, &quot;-- Contents of partial --&quot;);
          #   page.replace 'person_45', :partial =&gt; 'person', :object =&gt; @person
          #
          def replace(id, *options_for_render)
            call 'Element.replace', id, render(*options_for_render)
          end

          # Removes the DOM elements with the given +ids+ from the page.
          #
          # Example:
          #
          #  # Remove a few people
          #  # Generates: [&quot;person_23&quot;, &quot;person_9&quot;, &quot;person_2&quot;].each(Element.remove);
          #  page.remove 'person_23', 'person_9', 'person_2'
          #
          def remove(*ids)
            loop_on_multiple_args 'Element.remove', ids
          end

          # Shows hidden DOM elements with the given +ids+.
          #
          # Example:
          #
          #  # Show a few people
          #  # Generates: [&quot;person_6&quot;, &quot;person_13&quot;, &quot;person_223&quot;].each(Element.show);
          #  page.show 'person_6', 'person_13', 'person_223'
          #
          def show(*ids)
            loop_on_multiple_args 'Element.show', ids
          end

          # Hides the visible DOM elements with the given +ids+.
          #
          # Example:
          #
          #  # Hide a few people
          #  # Generates: [&quot;person_29&quot;, &quot;person_9&quot;, &quot;person_0&quot;].each(Element.hide);
          #  page.hide 'person_29', 'person_9', 'person_0'
          #
          def hide(*ids)
            loop_on_multiple_args 'Element.hide', ids
          end

          # Toggles the visibility of the DOM elements with the given +ids+.
          # Example:
          #
          #  # Show a few people
          #  # Generates: [&quot;person_14&quot;, &quot;person_12&quot;, &quot;person_23&quot;].each(Element.toggle);
          #  page.toggle 'person_14', 'person_12', 'person_23'      # Hides the elements
          #  page.toggle 'person_14', 'person_12', 'person_23'      # Shows the previously hidden elements
          #
          def toggle(*ids)
            loop_on_multiple_args 'Element.toggle', ids
          end

          # Displays an alert dialog with the given +message+.
          #
          # Example:
          #
          #   # Generates: alert('This message is from Rails!')
          #   page.alert('This message is from Rails!')
          def alert(message)
            call 'alert', message
          end

          # Redirects the browser to the given +location+ using JavaScript, in the same form as +url_for+.
          #
          # Examples:
          #
          #  # Generates: window.location.href = &quot;/mycontroller&quot;;
          #  page.redirect_to(:action =&gt; 'index')
          #
          #  # Generates: window.location.href = &quot;/account/signup&quot;;
          #  page.redirect_to(:controller =&gt; 'account', :action =&gt; 'signup')
          def redirect_to(location)
            url = location.is_a?(String) ? location : @context.url_for(location)
            record &quot;window.location.href = #{url.inspect}&quot;
          end

          # Reloads the browser's current +location+ using JavaScript
          #
          # Examples:
          #
          #  # Generates: window.location.reload();
          #  page.reload
          def reload
            record 'window.location.reload()'
          end

          # Calls the JavaScript +function+, optionally with the given +arguments+.
          #
          # If a block is given, the block will be passed to a new JavaScriptGenerator;
          # the resulting JavaScript code will then be wrapped inside &lt;tt&gt;function() { ... }&lt;/tt&gt;
          # and passed as the called function's final argument.
          #
          # Examples:
          #
          #   # Generates: Element.replace(my_element, &quot;My content to replace with.&quot;)
          #   page.call 'Element.replace', 'my_element', &quot;My content to replace with.&quot;
          #
          #   # Generates: alert('My message!')
          #   page.call 'alert', 'My message!'
          #
          #   # Generates:
          #   #     my_method(function() {
          #   #       $(&quot;one&quot;).show();
          #   #       $(&quot;two&quot;).hide();
          #   #    });
          #   page.call(:my_method) do |p|
          #      p[:one].show
          #      p[:two].hide
          #   end
          def call(function, *arguments, &amp;block)
            record &quot;#{function}(#{arguments_for_call(arguments, block)})&quot;
          end

          # Assigns the JavaScript +variable+ the given +value+.
          #
          # Examples:
          #
          #  # Generates: my_string = &quot;This is mine!&quot;;
          #  page.assign 'my_string', 'This is mine!'
          #
          #  # Generates: record_count = 33;
          #  page.assign 'record_count', 33
          #
          #  # Generates: tabulated_total = 47
          #  page.assign 'tabulated_total', @total_from_cart
          #
          def assign(variable, value)
            record &quot;#{variable} = #{javascript_object_for(value)}&quot;
          end

          # Writes raw JavaScript to the page.
          #
          # Example:
          #
          #  page &lt;&lt; &quot;alert('JavaScript with Prototype.');&quot;
          def &lt;&lt;(javascript)
            @lines &lt;&lt; javascript
          end

          # Executes the content of the block after a delay of +seconds+. Example:
          #
          #   # Generates:
          #   #     setTimeout(function() {
          #   #     ;
          #   #     new Effect.Fade(&quot;notice&quot;,{});
          #   #     }, 20000);
          #   page.delay(20) do
          #     page.visual_effect :fade, 'notice'
          #   end
          def delay(seconds = 1)
            record &quot;setTimeout(function() {\n\n&quot;
            yield
            record &quot;}, #{(seconds * 1000).to_i})&quot;
          end

          # Starts a script.aculo.us visual effect. See
          # ActionView::Helpers::ScriptaculousHelper for more information.
          def visual_effect(name, id = nil, options = {})
            record @context.send(:visual_effect, name, id, options)
          end

          # Creates a script.aculo.us sortable element. Useful
          # to recreate sortable elements after items get added
          # or deleted.
          # See ActionView::Helpers::ScriptaculousHelper for more information.
          def sortable(id, options = {})
            record @context.send(:sortable_element_js, id, options)
          end

          # Creates a script.aculo.us draggable element.
          # See ActionView::Helpers::ScriptaculousHelper for more information.
          def draggable(id, options = {})
            record @context.send(:draggable_element_js, id, options)
          end

          # Creates a script.aculo.us drop receiving element.
          # See ActionView::Helpers::ScriptaculousHelper for more information.
          def drop_receiving(id, options = {})
            record @context.send(:drop_receiving_element_js, id, options)
          end

          private
            def loop_on_multiple_args(method, ids)
              record(ids.size&gt;1 ?
                &quot;#{javascript_object_for(ids)}.each(#{method})&quot; :
                &quot;#{method}(#{ids.first.to_json})&quot;)
            end

            def page
              self
            end

            def record(line)
              returning line = &quot;#{line.to_s.chomp.gsub(/\;\z/, '')};&quot; do
                self &lt;&lt; line
              end
            end

            def render(*options_for_render)
              old_format = @context &amp;&amp; @context.template_format
              @context.template_format = :html if @context
              Hash === options_for_render.first ?
                @context.render(*options_for_render) :
                  options_for_render.first.to_s
            ensure
              @context.template_format = old_format if @context
            end

            def javascript_object_for(object)
              object.respond_to?(:to_json) ? object.to_json : object.inspect
            end

            def arguments_for_call(arguments, block = nil)
              arguments &lt;&lt; block_to_function(block) if block
              arguments.map { |argument| javascript_object_for(argument) }.join ', '
            end

            def block_to_function(block)
              generator = self.class.new(@context, &amp;block)
              literal(&quot;function() { #{generator.to_s} }&quot;)
            end

            def method_missing(method, *arguments)
              JavaScriptProxy.new(self, method.to_s.camelize)
            end
        end
      end

      # Yields a JavaScriptGenerator and returns the generated JavaScript code.
      # Use this to update multiple elements on a page in an Ajax response.
      # See JavaScriptGenerator for more information.
      #
      # Example:
      #
      #   update_page do |page|
      #     page.hide 'spinner'
      #   end
      def update_page(&amp;block)
        JavaScriptGenerator.new(@template, &amp;block).to_s
      end

      # Works like update_page but wraps the generated JavaScript in a &lt;script&gt;
      # tag. Use this to include generated JavaScript in an ERb template.
      # See JavaScriptGenerator for more information.
      #
      # +html_options+ may be a hash of &lt;script&gt; attributes to be passed
      # to ActionView::Helpers::JavaScriptHelper#javascript_tag.
      def update_page_tag(html_options = {}, &amp;block)
        javascript_tag update_page(&amp;block), html_options
      end

    protected
      def options_for_ajax(options)
        js_options = build_callbacks(options)

        js_options['asynchronous'] = options[:type] != :synchronous
        js_options['method']       = method_option_to_s(options[:method]) if options[:method]
        js_options['insertion']    = &quot;'#{options[:position].to_s.downcase}'&quot; if options[:position]
        js_options['evalScripts']  = options[:script].nil? || options[:script]

        if options[:form]
          js_options['parameters'] = 'Form.serialize(this)'
        elsif options[:submit]
          js_options['parameters'] = &quot;Form.serialize('#{options[:submit]}')&quot;
        elsif options[:with]
          js_options['parameters'] = options[:with]
        end

        if protect_against_forgery? &amp;&amp; !options[:form]
          if js_options['parameters']
            js_options['parameters'] &lt;&lt; &quot; + '&amp;&quot;
          else
            js_options['parameters'] = &quot;'&quot;
          end
          js_options['parameters'] &lt;&lt; &quot;#{request_forgery_protection_token}=' + encodeURIComponent('#{escape_javascript form_authenticity_token}')&quot;
        end

        options_for_javascript(js_options)
      end

      def method_option_to_s(method)
        (method.is_a?(String) and !method.index(&quot;'&quot;).nil?) ? method : &quot;'#{method}'&quot;
      end

      def build_observer(klass, name, options = {})
        if options[:with] &amp;&amp; (options[:with] !~ /[\{=(.]/)
          options[:with] = &quot;'#{options[:with]}=' + encodeURIComponent(value)&quot;
        else
          options[:with] ||= 'value' unless options[:function]
        end

        callback = options[:function] || remote_function(options)
        javascript  = &quot;new #{klass}('#{name}', &quot;
        javascript &lt;&lt; &quot;#{options[:frequency]}, &quot; if options[:frequency]
        javascript &lt;&lt; &quot;function(element, value) {&quot;
        javascript &lt;&lt; &quot;#{callback}}&quot;
        javascript &lt;&lt; &quot;)&quot;
        javascript_tag(javascript)
      end

      def build_callbacks(options)
        callbacks = {}
        options.each do |callback, code|
          if CALLBACKS.include?(callback)
            name = 'on' + callback.to_s.capitalize
            callbacks[name] = &quot;function(request){#{code}}&quot;
          end
        end
        callbacks
      end
    end

    # Converts chained method calls on DOM proxy elements into JavaScript chains
    class JavaScriptProxy &lt; ActiveSupport::BasicObject #:nodoc:

      def initialize(generator, root = nil)
        @generator = generator
        @generator &lt;&lt; root if root
      end

      private
        def method_missing(method, *arguments, &amp;block)
          if method.to_s =~ /(.*)=$/
            assign($1, arguments.first)
          else
            call(&quot;#{method.to_s.camelize(:lower)}&quot;, *arguments, &amp;block)
          end
        end

        def call(function, *arguments, &amp;block)
          append_to_function_chain!(&quot;#{function}(#{@generator.send(:arguments_for_call, arguments, block)})&quot;)
          self
        end

        def assign(variable, value)
          append_to_function_chain!(&quot;#{variable} = #{@generator.send(:javascript_object_for, value)}&quot;)
        end

        def function_chain
          @function_chain ||= @generator.instance_variable_get(:@lines)
        end

        def append_to_function_chain!(call)
          function_chain[-1].chomp!(';')
          function_chain[-1] += &quot;.#{call};&quot;
        end
    end

    class JavaScriptElementProxy &lt; JavaScriptProxy #:nodoc:
      def initialize(generator, id)
        @id = id
        super(generator, &quot;$(#{id.to_json})&quot;)
      end

      # Allows access of element attributes through +attribute+. Examples:
      #
      #   page['foo']['style']                  # =&gt; $('foo').style;
      #   page['foo']['style']['color']         # =&gt; $('blank_slate').style.color;
      #   page['foo']['style']['color'] = 'red' # =&gt; $('blank_slate').style.color = 'red';
      #   page['foo']['style'].color = 'red'    # =&gt; $('blank_slate').style.color = 'red';
      def [](attribute)
        append_to_function_chain!(attribute)
        self
      end

      def []=(variable, value)
        assign(variable, value)
      end

      def replace_html(*options_for_render)
        call 'update', @generator.send(:render, *options_for_render)
      end

      def replace(*options_for_render)
        call 'replace', @generator.send(:render, *options_for_render)
      end

      def reload(options_for_replace = {})
        replace(options_for_replace.merge({ :partial =&gt; @id.to_s }))
      end

    end

    class JavaScriptVariableProxy &lt; JavaScriptProxy #:nodoc:
      def initialize(generator, variable)
        @variable = variable
        @empty    = true # only record lines if we have to.  gets rid of unnecessary linebreaks
        super(generator)
      end

      # The JSON Encoder calls this to check for the +to_json+ method
      # Since it's a blank slate object, I suppose it responds to anything.
      def respond_to?(method)
        true
      end

      def to_json(options = nil)
        @variable
      end

      private
        def append_to_function_chain!(call)
          @generator &lt;&lt; @variable if @empty
          @empty = false
          super
        end
    end

    class JavaScriptCollectionProxy &lt; JavaScriptProxy #:nodoc:
      ENUMERABLE_METHODS_WITH_RETURN = [:all, :any, :collect, :map, :detect, :find, :find_all, :select, :max, :min, :partition, :reject, :sort_by, :in_groups_of, :each_slice] unless defined? ENUMERABLE_METHODS_WITH_RETURN
      ENUMERABLE_METHODS = ENUMERABLE_METHODS_WITH_RETURN + [:each] unless defined? ENUMERABLE_METHODS
      attr_reader :generator
      delegate :arguments_for_call, :to =&gt; :generator

      def initialize(generator, pattern)
        super(generator, @pattern = pattern)
      end

      def each_slice(variable, number, &amp;block)
        if block
          enumerate :eachSlice, :variable =&gt; variable, :method_args =&gt; [number], :yield_args =&gt; %w(value index), :return =&gt; true, &amp;block
        else
          add_variable_assignment!(variable)
          append_enumerable_function!(&quot;eachSlice(#{number.to_json});&quot;)
        end
      end

      def grep(variable, pattern, &amp;block)
        enumerate :grep, :variable =&gt; variable, :return =&gt; true, :method_args =&gt; [pattern], :yield_args =&gt; %w(value index), &amp;block
      end

      def in_groups_of(variable, number, fill_with = nil)
        arguments = [number]
        arguments &lt;&lt; fill_with unless fill_with.nil?
        add_variable_assignment!(variable)
        append_enumerable_function!(&quot;inGroupsOf(#{arguments_for_call arguments});&quot;)
      end

      def inject(variable, memo, &amp;block)
        enumerate :inject, :variable =&gt; variable, :method_args =&gt; [memo], :yield_args =&gt; %w(memo value index), :return =&gt; true, &amp;block
      end

      def pluck(variable, property)
        add_variable_assignment!(variable)
        append_enumerable_function!(&quot;pluck(#{property.to_json});&quot;)
      end

      def zip(variable, *arguments, &amp;block)
        add_variable_assignment!(variable)
        append_enumerable_function!(&quot;zip(#{arguments_for_call arguments}&quot;)
        if block
          function_chain[-1] += &quot;, function(array) {&quot;
          yield ::ActiveSupport::JSON::Variable.new('array')
          add_return_statement!
          @generator &lt;&lt; '});'
        else
          function_chain[-1] += ');'
        end
      end

      private
        def method_missing(method, *arguments, &amp;block)
          if ENUMERABLE_METHODS.include?(method)
            returnable = ENUMERABLE_METHODS_WITH_RETURN.include?(method)
            variable   = arguments.first if returnable
            enumerate(method, {:variable =&gt; (arguments.first if returnable), :return =&gt; returnable, :yield_args =&gt; %w(value index)}, &amp;block)
          else
            super
          end
        end

        # Options
        #   * variable - name of the variable to set the result of the enumeration to
        #   * method_args - array of the javascript enumeration method args that occur before the function
        #   * yield_args - array of the javascript yield args
        #   * return - true if the enumeration should return the last statement
        def enumerate(enumerable, options = {}, &amp;block)
          options[:method_args] ||= []
          options[:yield_args]  ||= []
          yield_args  = options[:yield_args] * ', '
          method_args = arguments_for_call options[:method_args] # foo, bar, function
          method_args &lt;&lt; ', ' unless method_args.blank?
          add_variable_assignment!(options[:variable]) if options[:variable]
          append_enumerable_function!(&quot;#{enumerable.to_s.camelize(:lower)}(#{method_args}function(#{yield_args}) {&quot;)
          # only yield as many params as were passed in the block
          yield(*options[:yield_args].collect { |p| JavaScriptVariableProxy.new(@generator, p) }[0..block.arity-1])
          add_return_statement! if options[:return]
          @generator &lt;&lt; '});'
        end

        def add_variable_assignment!(variable)
          function_chain.push(&quot;var #{variable} = #{function_chain.pop}&quot;)
        end

        def add_return_statement!
          unless function_chain.last =~ /return/
            function_chain.push(&quot;return #{function_chain.pop.chomp(';')};&quot;)
          end
        end

        def append_enumerable_function!(call)
          function_chain[-1].chomp!(';')
          function_chain[-1] += &quot;.#{call}&quot;
        end
    end

    class JavaScriptElementCollectionProxy &lt; JavaScriptCollectionProxy #:nodoc:\
      def initialize(generator, pattern)
        super(generator, &quot;$$(#{pattern.to_json})&quot;)
      end
    end
  end
end

require 'action_view/helpers/javascript_helper'
</pre>
    </div>